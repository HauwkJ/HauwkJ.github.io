<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[「较小值最大」赌注]]></title>
      <url>/2018/10/24/%E3%80%8C%E8%BE%83%E5%B0%8F%E5%80%BC%E6%9C%80%E5%A4%A7%E3%80%8D%E8%B5%8C%E6%B3%A8/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4653" target="_blank" rel="external">题目链接</a></p>
<p>ps：这道题是在校内模拟赛见到的，所以题目当然是模改过的啦=。=  原题提交链接在上面=。=</p>
<p><strong>问题描述</strong><br>一天，你进入了<strong>神仙 lzc</strong>的神仙赌场。 神仙 lzc 实在是肽聚了，他觉得用一个本体来虐人太无聊了，于是就造出了 N 个分身。 这 N 个分身每个都是庄家。 你可以到庄家那边下注，每次可以猜大猜小，<strong>猜一次一元钱</strong>。 每一次开彩前，你都可以到任意个庄家那里下赌注。 如果开彩结果是大，你就可以得到你之前猜大的庄家相应的 ai 元钱。 如果开彩结果是小，你就可以得到你之前猜小的庄家相应的 bi 元钱。 你<strong>可以在同一个庄家那里既猜大又猜小（这样是两块钱），也可以什么都不猜（这样不用 钱）</strong>。 现在你对这个整天装逼装弱的神仙 lzc 看得实在是不爽，想要从它的分身中坑走尽量多的 钱。 但是阴险狡诈爱装逼爱装弱的神仙 lzc 会根据你下注的信息控制开彩的结果，让你赢的钱 数尽量少。 问怎么样下注，才能坑走神仙 lzc 最多的钱。</p>
<a id="more"></a>
<p><strong>输入</strong><br>第一行一个数字 N。表示有 N 个庄家。 接下来 N 行，每行 2 个实数，分别表示这个庄家的 ai 和 bi。</p>
<p><strong>输出</strong><br>一个四位小数，表示最多能坑走神仙 lzc 的钱。</p>
<p><strong>输入输出样例</strong><br><strong>输入样例</strong> </p>
<blockquote>
<p>4<br>1.4 3.7<br>1.2 2<br>1.6 1.4<br>1.9 1.5</p>
</blockquote>
<p><strong>输出样例</strong> </p>
<blockquote>
<p>0.5000</p>
</blockquote>
<p><strong>约定和数据范围</strong><br>对于 20% 的数据，1 ≤ n ≤ 10；<br>对于 60% 的数据，1 ≤ n ≤ 1000；<br>对于 100% 的数据，1 ≤ n ≤ 100000， 1.0 ≤ ai,bi ≤ 1000.0。</p>
<p>看完题目之后首先我就被样例给搞晕啦，0.5000是怎么来的，嗯……是这样来的：</p>
<p><strong>样例解释</strong></p>
<p>最优策略是第一个庄家压小和第三个庄家压大和第四个庄家压大：</p>
<p>如果本局开小，收益是 3.7-3=0.7。<br>如果本局开大，收益是 1.6+1.9-3=0.5。<br>最小可能收益是 0.5。</p>
<hr>
<p>原来是这样！我们可以进行任意的押注选择，神仙lzc会根据你的选择，让你能赚到的钱尽量少，就是说如果你在这局游戏中压了一些大，压了一些小，开奖的时候神仙lzc会根据开奖后你能够赚到的钱数进行阴险操纵，如果开大你能赚到的钱更多，那么他就会操纵开小，如果开小你能赚到的钱更多，那么他就操纵开大。</p>
<p>我们既可以压大又可以压小，可以同时压，可以同时不压，<strong>那么压大和压小之间就是完全独立的选择，互不影响</strong>。<br>我们的<strong>成本为压大的个数+压小的个数（压一次一元）， 收益为压大收益和压小收益中较小的一个 - 成本</strong>（有可能为负，例如第一个庄家既压大又压小，lzc操纵开大， 那么收益为：1.4 - 2（押注两次的成本） = -0.6，这样我们就赔了0.6元）。</p>
<p>所以我们的工作即为使得 （开奖收益较小值 - 成本）最大。</p>
<p>既然成本都为一元， 那么同等情况下压受益较大的赚钱肯定更多。a[]与b[]之间互不影响，所以我们将a[] 及b[]从大到小进行排序, 然后在原数组上求出前缀和（a[i]即为压i个大，b[i]即为压i个小）。 然后从小到大枚举我们压i个大及压j个小能获得的最终收益，取max即为答案！</p>
<p>附上代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">" = "</span> &lt;&lt; x &lt;&lt; std::endl</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> minxy(x, y) ((x) &lt; (y) ? (x) : (y))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxxy(x, y) ((x) &gt; (y) ? (x) : (y))</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> res = <span class="number">0</span>; <span class="keyword">int</span> flag = <span class="number">1</span>;</div><div class="line">	<span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) flag = <span class="number">-1</span>;</div><div class="line">	<span class="keyword">for</span>(; <span class="built_in">isdigit</span>(ch); ch = getchar()) res = (res &lt;&lt; <span class="number">3</span>) + (res &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>;</div><div class="line">	<span class="keyword">return</span> (res * flag);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N_MAX = <span class="number">100007</span>;</div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="keyword">double</span> ans, a[N_MAX], b[N_MAX], har;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> r1, <span class="keyword">double</span> r2)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> r1 &gt; r2;</div><div class="line">&#125;<span class="comment">//sort的比较函数</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    freopen(<span class="string">"coin.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">    freopen(<span class="string">"coin.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</div><div class="line">	n = read();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;a[i], &amp;b[i]);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="built_in">std</span>::sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</div><div class="line">	<span class="built_in">std</span>::sort(b + <span class="number">1</span>, b + n + <span class="number">1</span>, cmp);</div><div class="line">    <span class="comment">//排序</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) b[i] += b[i - <span class="number">1</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) a[i] += a[i - <span class="number">1</span>];</div><div class="line">    <span class="comment">//求前缀和</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</div><div class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</div><div class="line">            har = minxy(a[i], b[j]) - i - j;</div><div class="line">            <span class="comment">//minxy(a[i], b[i]) : lzc会操纵我们得到的是收益较小的一个</span></div><div class="line">            <span class="comment">//- i - j ： 减去我们压了(i + j)个的成本</span></div><div class="line">            ans = maxxy(ans, har);</div><div class="line">            <span class="comment">//求最终收益的最大值</span></div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//枚举所有方案</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%.4lf"</span>,ans);</div><div class="line">	fclose(<span class="built_in">stdin</span>);</div><div class="line">    fclose(<span class="built_in">stdout</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很开心地我们就提交了程序， 哭着回来了。60分。<br>n^2的复杂度TLE了 QAQ</p>
<p>这样想，既然较大收益已经固定的时候，我们把较大收益定住，然后使较小收益尽量大，较小收益越大，最终收益也就越大！<br>这样只需要跑一遍定压大的情况，再跑一遍定压小的情况，求下最终收益max就可以了。复杂度就从O(n^2)优化到O(4n)了，轻松跑过~</p>
<p>附上代码!：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100005</span>;</div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="keyword">double</span> ans, a[MAXN] , b[MAXN];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> x , <span class="keyword">double</span> y)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> x &gt; y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span> ,&amp;n);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) </div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span> ,a + i , b + i);</div><div class="line">	sort(a + <span class="number">1</span> , a + n + <span class="number">1</span> , cmp);</div><div class="line">	sort(b + <span class="number">1</span> , b + n + <span class="number">1</span> , cmp);</div><div class="line">    <span class="comment">//单次押注收益排序</span></div><div class="line">    </div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) &#123;</div><div class="line">		a[i] += a[i - <span class="number">1</span>];</div><div class="line">		b[i] += b[i - <span class="number">1</span>];</div><div class="line">	&#125;<span class="comment">//前缀和</span></div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> , j = <span class="number">1</span> ; i &lt;= n ; i++) &#123;</div><div class="line">		<span class="keyword">while</span>(j &lt;= n &amp;&amp; b[j] &lt; a[i]) j++;</div><div class="line">		<span class="keyword">if</span>(j &lt;= n) ans = max(ans , a[i] - i - j );</div><div class="line">	&#125;</div><div class="line">    <span class="comment">//定压大，移压小</span></div><div class="line">    </div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> , j = <span class="number">1</span> ; i &lt;= n ; i++) &#123;</div><div class="line">		<span class="keyword">while</span>(j &lt;= n &amp;&amp; a[j] &lt; b[i]) j++;</div><div class="line">		<span class="keyword">if</span>(j &lt;= n) ans = max(ans , b[i] - i - j );</div><div class="line">	&#125;</div><div class="line">    <span class="comment">//定压小，移压大</span></div><div class="line"></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%.4lf\n"</span>,ans );</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「初等数论初步」素数及其判别法]]></title>
      <url>/2018/10/23/%E3%80%8C%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA%E5%88%9D%E6%AD%A5%E3%80%8D%E7%B4%A0%E6%95%B0%E5%8F%8A%E5%85%B6%E5%88%A4%E5%88%AB%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><strong>素数：仅有两个正因数的正整数，即为正因数只有1和本身的数，也称质数</strong></p>
<p><strong>合数：不是素数又不是1的正整数</strong></p>
<ul>
<li>1既不是素数(只有一个正因子)，也不是合数.</li>
<li>2是唯一的偶素数，也是最小的素数.</li>
</ul>
<p><strong> 我们发现，每个正整数x除1外的最小正因数p是一个素数</strong></p>
<a id="more"></a>
<p>证明：如果p不是一个素数的话，那么p必定有除1、p以外的正因数q，使得 q|p, 那么q|x, 那么q是x的比p小的正因数，所以p就不是x的最小正因数了，与已知矛盾.</p>
<p>判断一个数x是不是素数，只需要判断到sqrt(x)即可，因为如果x是一个合数，那么在（1, sqrt(x)]中的因数q，一定有一个[sqrt(x), x）中的因数p与其对应，使得p*q == n，且sqrt(x)^2 == n;</p>
<p><strong>如果大于1的整数a不能被所有不超过sqrt(a)的素数整除, 那么a一定是素数.</strong></p>
<p> 所以用代码判定一个数是不是素数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//试除法 O(根号n)</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">primer</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++) &#123;</div><div class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>埃拉托斯特尼（Eratosthenes）筛法</strong>–埃筛</p>
<p>例题：找出1~100以内的全部素数.</p>
<p>做法：只需要把1~100以内的合数去掉即可，对于1~100以内的每个合数，他一定能被某个不超过sqrt(x)的整数整除，从而能被不超过sqrt(100) = 10的整数整除。我们只需要把不超过10的素数（2， 3， 5， 7）除其本身以外的倍数以及1去掉，剩下的就是不超过100的全部素数。这种寻求素数的方法叫做<strong>埃拉托斯特尼(Eratosthenes)筛法</strong>即 <strong>埃筛</strong>.</p>
<p><strong>先找sqrt(n)以内的素数，然后倍数增长标记.</strong></p>
<p>附上埃筛代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//埃筛 O(NloglogN) 接近线性</span></div><div class="line"><span class="keyword">bool</span> v[n_max + <span class="number">1</span>];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">primer</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</div><div class="line">        <span class="keyword">if</span>(v[i]) <span class="keyword">continue</span>;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n/i; j++) &#123;</div><div class="line">            v[i*j] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>线性筛法</strong><br>线性筛法是一种O(n)的算法，但是代码复杂度较高，不易考场书写，其实埃筛就已经完全够用，它已经接近线性了，所以<strong>考场书写推荐埃筛</strong>！这里就不进行线性筛法的讲解了，有兴趣的同学可以自行网上搜索学习，附上代码吧：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//线性筛法 O(n) 写法较难 用埃筛就可以了</span></div><div class="line"><span class="keyword">int</span> v[N_MAX], prime[N_MAX];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">primer</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v)); <span class="comment">//最小质因子;</span></div><div class="line">    m = <span class="number">0</span>; <span class="comment">//质数数量;</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</div><div class="line">        <span class="keyword">if</span>(v[i] == <span class="number">0</span>) &#123;v[i] == i; prime[++m] = i;&#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</div><div class="line">            <span class="keyword">if</span>(prime[j] &gt; v[i] || prime[j] &gt; n/i) <span class="keyword">break</span>;</div><div class="line">            v[i * prime[j]] = prime[j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, prime[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「NOIP2015」信息传递]]></title>
      <url>/2018/10/23/1979/</url>
      <content type="html"><![CDATA[<p><strong>使用拓扑求最大环长度；</strong></p>
<p><a href="https://vijos.org/p/1979" target="_blank" rel="external">题目链接</a></p>
<p>有 n 个同学（编号为 1 到 n）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为 i 的同学的信息传递对象是编号为 T_i 的同学。</p>
<p>游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息， 但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？</p>
<a id="more"></a>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p><strong>输入格式</strong><br>输入共 2 行。</p>
<p>第 1 行包含 1 个正整数 n，表示 n 个人。</p>
<p>第 2 行包含 n 个用空格隔开的正整数 T_1T , T_2T, … … , T_nT，其中第 i 个整数T_iT 表示编号为 i 的同学的信息传递对象是编号为 T_iT<br>T_iT≤ n 且 T_iT ≠ i。</p>
<p>数据保证游戏一定会结束。</p>
<p><strong>输出格式</strong><br>输出共 1 行，包含 1 个整数，表示游戏一共可以进行多少轮。</p>
<p><strong>样例1</strong><br>样例输入1</p>
<blockquote>
<p>5<br>2 4 2 3 1</p>
</blockquote>
<p>样例输出1</p>
<blockquote>
<p>3</p>
</blockquote>
<p><strong>限制</strong><br>对于 30%的数据， n ≤ 200；</p>
<p>对于 60%的数据，n ≤ 2500；</p>
<p>对于 100%的数据，n ≤ 200000。</p>
<p>提示<br>【输入输出样例 1 说明】</p>
<p><img src="https://cdn.vijos.org/fs/39caebb96fd97d7553ff6594f450bbd4e37624b9" alt="此处输入图片的描述"></p>
<p>游戏的流程如图所示。当进行完第 3 轮游戏后，4 号玩家会听到 2 号玩家告诉他自己的生日，所以答案为 3。当然，第 3 轮游戏后，2 号玩家、3 号玩家都能从自己的消息来源得知自己的生日，同样符合游戏结束的条件。</p>
<p><strong>来源</strong><br>NOIP 2015 提高组 Day 1 第二题</p>
<hr>
<p>  读完这道题之后，我们想一下，有对象关系， 有传递关系，那么我们就可以把信息存到一份图里！&gt; . &lt;</p>
<p>  存完图之后，思考一下，如果自己的生日信息能传回自己，那么他就存在于一个环里（注意:图中可能存在多个环）。我们首先用拓扑把不在环上的点打上标记，然后再求所有环中的 <strong>最长环的长度</strong>，就是游戏可进行的最大轮数了。问题解决了！</p>
<p>  本题是有向图，我们使用拓扑来解决问题；</p>
<p>  附上代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">" = "</span> &lt;&lt; x &lt;&lt;std::endl</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> max(x, y) ((x) &gt; (y) ? x : y)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> res = <span class="number">0</span>; <span class="keyword">int</span> flag = <span class="number">1</span>;</div><div class="line">	<span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) flag = <span class="number">-1</span>;</div><div class="line">	<span class="keyword">for</span>(; <span class="built_in">isdigit</span>(ch); ch = getchar()) res = (res &lt;&lt; <span class="number">3</span>) + (res &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>;</div><div class="line">	<span class="keyword">return</span> (res * flag);</div><div class="line">&#125;<span class="comment">//快读</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> n, ans, tot, ver[<span class="number">200007</span>], per[<span class="number">200007</span>];</div><div class="line"><span class="comment">//ver[]数组存储“父亲”数量</span></div><div class="line"><span class="comment">//per[]数组存储传递对象</span></div><div class="line"><span class="keyword">bool</span> vis[<span class="number">200007</span>];<span class="comment">//为节点打标记</span></div><div class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;que;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	ans = <span class="number">0x7fffffff</span>;</div><div class="line">	tot = <span class="number">0x7fffffff</span>;</div><div class="line">	n = read();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">		<span class="keyword">int</span> x = read();</div><div class="line">		per[i] = x;</div><div class="line">		ver[x] ++;</div><div class="line">	&#125; </div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">		<span class="keyword">if</span>(ver[i] == <span class="number">0</span>) &#123;</div><div class="line">			vis[i] = <span class="number">1</span>;</div><div class="line">			que.push(i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">while</span>(!que.empty()) &#123;</div><div class="line">		<span class="keyword">int</span> cnt = que.front();</div><div class="line">		que.pop();</div><div class="line">		ver[per[cnt]] --;</div><div class="line">		<span class="keyword">if</span>(ver[per[cnt]] == <span class="number">0</span>) &#123;</div><div class="line">			vis[per[cnt]] = <span class="number">1</span>;</div><div class="line">			que.push(per[cnt]);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//为所有不在环上的点打上标记</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">		<span class="keyword">if</span>(vis[i] == <span class="number">0</span> &amp;&amp; ver[i] != <span class="number">0</span>) &#123;</div><div class="line">			vis[i] = <span class="number">1</span>;</div><div class="line">			tot = <span class="number">1</span>;</div><div class="line">			<span class="keyword">int</span> j = per[i];</div><div class="line">			<span class="keyword">while</span>(!vis[j]) &#123;</div><div class="line">				vis[j] = <span class="number">1</span>;<span class="comment">//每个点只有唯一一个传递对象，所以它只存在于一个环上，所以在此时遍历到它，便可以直接打上标记；</span></div><div class="line">				j = per[j];</div><div class="line">				tot ++;<span class="comment">//记录此环的长度</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(tot &lt; ans) ans = tot;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//求最长环长度</span></div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「NOIP2014」寻找道路]]></title>
      <url>/2018/10/22/2296/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2296" target="_blank" rel="external">题目链接</a></p>
<p>在有向图 G 中，每条边的长度均为 1，现给定起点和终点，请你在图中找一条从起点到终点的路径，该路径满足以下条件：</p>
<ul>
<li>路径上的所有点的出边所指向的点都直接或间接与终点连通。 在满足条件1的情况下使路径最短。</li>
<li>注意：图 G 中可能存在重边和自环，题目保证终点没有出边。</li>
</ul>
<p>请你输出符合条件的路径的长度。</p>
<a id="more"></a>
<p><strong>输入输出格式</strong><br><strong>输入格式：</strong></p>
<p>第一行有两个用一个空格隔开的整数 n 和 m，表示图有 n 个点和 m 条边。</p>
<p>接下来的 m 行每行 2 个整数 x,y，之间用一个空格隔开，表示有一条边从点 x 指向点y。</p>
<p>最后一行有两个用一个空格隔开的整数 s,t，表示起点为 s，终点为 t。</p>
<p><strong>输出格式</strong>：</p>
<p>输出只有一行，包含一个整数，表示满足题目描述的最短路径的长度。如果这样的路径不存在，输出−1。</p>
<p><strong>输入输出样例</strong><br><strong>输入样例#1：</strong> </p>
<blockquote>
<p>3 2</p>
<p>1 2</p>
<p>2 1</p>
<p>1 3</p>
</blockquote>
<p><strong>输出样例#1：</strong> </p>
<blockquote>
<p>-1</p>
</blockquote>
<p><strong>输入样例#2：</strong> </p>
<blockquote>
<p>6 6</p>
<p>1 2</p>
<p>1 3</p>
<p>2 6</p>
<p>2 5</p>
<p>4 5</p>
<p>3 4</p>
<p>1 5</p>
</blockquote>
<p><strong>输出样例#2：</strong> </p>
<blockquote>
<p>3</p>
</blockquote>
<p><strong>说明</strong><br>解释1：</p>
<p>如上图所示，箭头表示有向道路，圆点表示城市。起点11与终点33不连通，所以满足题目描述的路径不存在，故输出−1 。</p>
<p>解释2：</p>
<p>如上图所示，满足条件的路径为1- &gt;3- &gt;4- &gt;5。注意点2不能在答案路径中，因为点2连了一条边到点6，而点6不与终点5连通。</p>
<hr>
<p>当我读完这道题的时候，noip竟然会考这么裸的最短*？ 对，这当然是我的错觉。看到样例解释2的时候我就明白了这道题才没有那么naive；</p>
<p>但是我头铁嘛对不对，先写个dijkstra试一试叭；</p>
<p>嗯，第一个样例没问题，但是第二个样例，我得到了答案：2——这显然是没有考虑条件2；</p>
<p>我们这样想，和终点不 直接或间接 连接， 那么我们如果建一个反图，反跑（以终点为起点）一遍dijkstra，如果某个点的最短距离为INF，显然这个点和终点（正常图）是不连接的；</p>
<p>我们把和终点（正常图）不连接的点找到了，下一步，我们就去找图（正常图）中出边与这些点直接相连的点，打上标记，表明这些点是不可出现在题目中要求的最短路径中的；node[N_MAX] 、vis[N_MAX]；</p>
<p>把去点操作完成之后， 忽然发现，既然只要输出最短路径长度即可，那么反图和正常图跑出来的结果就是一样的！okay,直接在之前建好的反图上面再跑一边dijkstra，问题解决了！上代码！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">" = "</span> &lt;&lt; x &lt;&lt; std::endl</span></div><div class="line"><span class="comment">//DEBUG时用的操作</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> res = <span class="number">0</span>; <span class="keyword">int</span> flag = <span class="number">1</span>;</div><div class="line">	<span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) flag = <span class="number">-1</span>;</div><div class="line">	<span class="keyword">for</span>(; <span class="built_in">isdigit</span>(ch); ch = getchar()) res = (res &lt;&lt; <span class="number">3</span>) + (res &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>;</div><div class="line">	<span class="keyword">return</span> (res * flag);</div><div class="line">&#125;<span class="comment">//快读</span></div><div class="line"> </div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N_MAX = <span class="number">10000</span> + <span class="number">7</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> M_MAX = <span class="number">200000</span> + <span class="number">7</span>;</div><div class="line"><span class="keyword">int</span> n, m, num, head[N_MAX], dist[N_MAX], ans, tot, start, endd;</div><div class="line"><span class="keyword">bool</span> vis[N_MAX];<span class="comment">//判断某个点是否符合条件2；</span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></div><div class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec;</div><div class="line">&#125;node[N_MAX];<span class="comment">//储存和终点不相连的点的“父亲”；</span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></div><div class="line">	<span class="keyword">int</span> to, w, next, from;</div><div class="line">&#125;edge[M_MAX];</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</div><div class="line">	edge[++num].to = to;</div><div class="line">	edge[num].from = from;</div><div class="line">	edge[num].w = w;</div><div class="line">	edge[num].next = head[from];</div><div class="line">	head[from] = num;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dist</span>&#123;</span></div><div class="line">	<span class="keyword">int</span> x, dist;</div><div class="line">	Dist(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> dist = INF) : x(x), dist(dist) &#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Dist l, Dist r)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> l.dist &gt; r.dist;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">priority_queue &lt;Dist, <span class="built_in">vector</span>&lt;Dist&gt;, Dist&gt; que;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">		dist[i] = INF;</div><div class="line">	&#125;</div><div class="line">	dist[start] = <span class="number">0</span>;</div><div class="line">	que.push(Dist(start, <span class="number">0</span>));</div><div class="line">	<span class="keyword">while</span>(!que.empty()) &#123;</div><div class="line">		Dist tmp = que.top();</div><div class="line">		que.pop();</div><div class="line">		<span class="keyword">if</span>(vis[tmp.x]) <span class="keyword">continue</span>;<span class="comment">//如何这个点非法，即不满足条件2；</span></div><div class="line">		<span class="keyword">if</span>(dist[tmp.x] != tmp.dist) <span class="keyword">continue</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = head[tmp.x]; j; j = edge[j].next) &#123;</div><div class="line">			<span class="keyword">if</span>(dist[edge[j].to] &gt; dist[edge[j].from] + edge[j].w) &#123;</div><div class="line">				dist[edge[j].to] = dist[edge[j].from] + edge[j].w;</div><div class="line">				que.push(Dist(edge[j].to, dist[edge[j].to]));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	n = read(); m = read();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">		<span class="keyword">int</span> x = read(), y = read();</div><div class="line">		add_edge(y, x, <span class="number">1</span>);<span class="comment">//建反图；</span></div><div class="line">		node[y].vec.push_back(x);<span class="comment">//存“父亲”；</span></div><div class="line">	&#125;</div><div class="line">	endd = read(); start = read();<span class="comment">//倒跑最短路；</span></div><div class="line">	dijkstra();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">		<span class="keyword">if</span>(dist[i] == INF) &#123;</div><div class="line">			vis[i] = <span class="number">1</span>;</div><div class="line">			<span class="keyword">while</span>(node[i].vec.size()) &#123;</div><div class="line">				vis[node[i].vec.back()] = <span class="number">1</span>;</div><div class="line">				node[i].vec.pop_back();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;<span class="comment">//判断不合法的点集；</span></div><div class="line">	dijkstra();</div><div class="line">	<span class="keyword">int</span> t = dist[endd];</div><div class="line">	<span class="keyword">if</span>(t == INF) &#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Bellman Ford]]></title>
      <url>/2018/07/26/Bellman%20Ford/</url>
      <content type="html"><![CDATA[<p>Bellman Ford同样是一种单源最短路算法，它的优秀之出在于它可以处理带有负边权的图，我们先来看看核心代码：</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n - <span class="number">1</span>; k ++) &#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">		<span class="keyword">if</span>(dist[edge[i].to] &gt; dist[edge[i].from] + edge[i].w) &#123;</div><div class="line">			dist[edge[i].to] = dist[edge[i].from] + edge[i].w;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码中，外循环一共循环了n - 1次（n为顶点的个数），内循环循环了m次（m为边的个数），dist为源点到其余各点的距离。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(dist[edge[i].to] &gt; dist[edge[i].from] + edge[i].w) &#123;</div><div class="line">			dist[edge[i].to] = dist[edge[i].from] + edge[i].w;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>上面这两行代码的意思是，看看能否通过第i条边，使得源点到第i条边的终点的距离变短。这其实与dijkstra的<strong>松弛</strong>操作是一样的。现在我们要把所有的边都松弛一遍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">		<span class="keyword">if</span>(dist[edge[i].to] &gt; dist[edge[i].from] + edge[i].w) &#123;</div><div class="line">			dist[edge[i].to] = dist[edge[i].from] + edge[i].w;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>在第1轮对所有边进行松弛之后，得到的是从源点<strong>只经过一条边</strong>到达其余个顶点的最短路径长度。在第2轮对所有的边进行松弛之后，得到的是从源点<strong>最多经过两条边</strong>到达其余各顶点的最短路径长度。如果进行k轮的话，得到的就是从源点<strong>最多经过k条边</strong>到达其余各顶点的最短路径长度。</p>
<p>我们最多进行<strong>n-1</strong>轮松弛就可以了，因为在一个含n个点的图中，任意两点间的最短路径最多包含n-1条边。</p>
<p><a href="http://codevs.cn/problem/1557/" target="_blank" rel="external">题目链接</a></p>
<p>热浪大家已经很熟悉了，这道题也可以作为<strong>Bellman Ford</strong>算法的模板题，大家可以用这道题来检验自己算法的准确性。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt;std:: endl</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> res = <span class="number">0</span>; <span class="keyword">int</span> flag = <span class="number">1</span>;</div><div class="line">	<span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) flag = <span class="number">-1</span>;</div><div class="line">	<span class="keyword">for</span>(; <span class="built_in">isdigit</span>(ch); ch = getchar()) res = (res &lt;&lt; <span class="number">3</span>) + (res &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>;</div><div class="line">	<span class="keyword">return</span> (res * flag);</div><div class="line">&#125;<span class="comment">//快读  需要用到头文件&lt;cctype&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N_max = <span class="number">2500</span> + <span class="number">7</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> M_max = <span class="number">13000</span> + <span class="number">7</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, m, start, end, num;</div><div class="line"><span class="keyword">int</span> dis[N_max];</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></div><div class="line">	<span class="keyword">int</span> from, to, w, next;</div><div class="line">&#125;edge[M_max];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</div><div class="line">	edge[++num].to = to;</div><div class="line">	edge[num].w = w;</div><div class="line">	edge[num].from = from;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BellmanFord</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</div><div class="line">		dis[i] = INF;</div><div class="line">	&#125;</div><div class="line">	dis[start] = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - <span class="number">1</span>; j ++) &#123;</div><div class="line">		<span class="keyword">bool</span> check = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * m; i++) &#123;</div><div class="line">			<span class="keyword">if</span>(dis[edge[i].to] &gt; dis[edge[i].from] + edge[i].w) &#123;</div><div class="line">				dis[edge[i].to] = dis[edge[i].from] + edge[i].w;</div><div class="line">				check = <span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(check == <span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//如果这一轮松弛操作中，如果dis数组没有任何变动，</span></div><div class="line">        那么就可以说明所有点的dis值都已经确定了，便可以退出循环。</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> dis[end];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	n = read(); m = read(); start = read(); end = read();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</div><div class="line">		<span class="keyword">int</span> x, y, z;</div><div class="line">		x = read(); y = read(); z = read();</div><div class="line">		add_edge(x, y, z);</div><div class="line">		add_edge(y, x, z);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * m; i ++) &#123;</div><div class="line">		<span class="keyword">if</span>(dis[edge[i].to] &gt; dis[edge[i].from] + edge[i].w) &#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"fuhuan\n"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="comment">//如果在Bellman Ford跑完后，dis数组仍可以变动，则说明图中存在负环。</span></div><div class="line">	</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, BellmanFord());</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「NOIP2013」积木大赛]]></title>
      <url>/2017/11/06/3288/</url>
      <content type="html"><![CDATA[<p><a href="http://codevs.cn/problem/3288/" target="_blank" rel="external">题目链接</a></p>
<p>春春幼儿园举办了一年一度的“积木大赛”。今年比赛的内容是搭建一座宽度为 n 的大厦，大厦可以看成由 n 块宽度为1的积木组成，第i块积木的最终高度需要是hi。<br>在搭建开始之前，没有任何积木<strong>（可以看成 n 块高度为 0 的积木）</strong>。接下来每次操作，小朋友们可以选择一段连续区间<strong>[L,R]</strong>，然后将第 L 块到第 R 块之间<strong>（含第 L 块和第 R 块）</strong>所有积木的高度分别增加1。<br>小 M 是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。</p>
<a id="more"></a>
<h4 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h4><p>输入包含两行，第一行包含一个整数 n，表示大厦的宽度。<br>第二行包含 n 个整数，第i个整数为hi</p>
<h4 id="输出描述-Output-Description"><a href="#输出描述-Output-Description" class="headerlink" title="输出描述 Output Description"></a>输出描述 Output Description</h4><p>仅一行，即建造所需的最少操作数。</p>
<h4 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">5</div><div class="line">2 3 4 1 2</div></pre></td></tr></table></figure>
<h4 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">5</div></pre></td></tr></table></figure>
<p>由题意可知，我们可以一次搭不间断的一整层（高度为1）；如果模拟的话，要写一大堆东西，占代码量还比较麻烦；那么我们根据每两座楼之间的差值来探索，每有一个差值，就说明出现一个间断，那么就需要多一次操作；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> max(x, y) ((x) &gt; (y) ? (x) : (y))</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> n, h[<span class="number">100005</span>], dec[<span class="number">100005</span>], ans;<span class="comment">//dec数组存储差值；</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> res = <span class="number">0</span>; <span class="keyword">int</span> flag = <span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span>(ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) &#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>) flag = <span class="number">-1</span>; ch = getchar();&#125;</div><div class="line">	<span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;res = res * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = getchar();&#125;</div><div class="line">	<span class="keyword">return</span> (res * flag);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	n = read();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;h[i] = read(); <span class="keyword">if</span>(h[i] &gt; h[i - <span class="number">1</span>]) dec[i] = h[i] - h[i - <span class="number">1</span>];&#125;</div><div class="line">    <span class="comment">//如果比前一座高，那么我们需要多一次操作；如果矮的话，我们之前搭的时候就已经搭完了，不需要再搭了；</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">		ans += dec[i];</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NOIP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「NOIP2012」Vigenère密码]]></title>
      <url>/2017/11/03/1197/</url>
      <content type="html"><![CDATA[<p><a href="http://codevs.cn/problem/1197/" target="_blank" rel="external">题目链接</a></p>
<p>16 世纪法国外交家Blaise de Vigenère设计了一种多表密码加密算法——Vigenère密码。Vigenère 密码的加密解密算法简单易用，且破译难度比较高，曾在美国南北战争中为南军所广泛使用。</p>
<p>在密码学中，我们称需要加密的信息为明文，用 M 表示；称加密后的信息为密文，用C 表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为k。 在Vigenère密码中， 密钥k是一个字母串， k=k1k2…kn。当明文M=m1m2…mn时，得到的密文C=c1c2…cn，其中<strong>ci=mi®ki</strong>，运算®的规则如下表所示：</p>
<p>Vigenère加密在操作时需要注意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1.  ®运算忽略参与运算的字母的大小写，并保持字母在明文 M中的大小写形式；</div><div class="line">2.  当明文M的长度大于密钥k的长度时，将密钥k 重复使用。</div></pre></td></tr></table></figure>
<p>例如，明文M=Helloworld，密钥k=abc 时，密文C=Hfnlpyosnd。</p>
<p><strong>这里题面的表不是很好弄，还请大家点击题目链接看题</strong>；</p>
<a id="more"></a>
<h4 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h4><p>输入共2行。</p>
<p>第一行为一个字符串，表示密钥k，长度不超过100，其中仅包含大小写字母。第二为一个字符串，表示经加密后的密文，长度不超过1000，其中仅包含大小写字母</p>
<h4 id="输出描述-Output-Description"><a href="#输出描述-Output-Description" class="headerlink" title="输出描述 Output Description"></a>输出描述 Output Description</h4><p>输出共1行，一个字符串，表示输入密钥和密文所对应的明文</p>
<h4 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CompleteVictory</div><div class="line"></div><div class="line">Yvqgpxaimmklongnzfwpvxmniytm</div></pre></td></tr></table></figure>
<h4 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Wherethereisawillthereisaway</div></pre></td></tr></table></figure>
<p>NOIP2012 Day1T1, 本题还是比较简单，纯模拟；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> len, lenk, cnt = <span class="number">1</span>;<span class="comment">//len密文长度， lenk密钥长度；</span></div><div class="line"><span class="keyword">char</span> keyy[<span class="number">105</span>], key[<span class="number">1005</span>], mi[<span class="number">1005</span>], light[<span class="number">1005</span>], abc[<span class="number">27</span>], asc[<span class="number">26</span>];</div><div class="line"><span class="comment">//key存储输入的密钥， mi存储输入的密文，light存储明文，abc存储26个英文字母；</span></div><div class="line"><span class="keyword">bool</span> flag[<span class="number">1005</span>];<span class="comment">//用于还原大小写；</span></div><div class="line"><span class="comment">//本题中全部转化为小写字母，方便操作；</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> x, <span class="keyword">char</span> y)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> pos = y - <span class="string">'a'</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) &#123;</div><div class="line">		asc[i] = <span class="string">'a'</span> + pos;</div><div class="line">		<span class="keyword">if</span>(pos == <span class="number">25</span>) pos = <span class="number">0</span>;</div><div class="line">		<span class="keyword">else</span> pos ++; </div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) &#123;</div><div class="line">		<span class="keyword">if</span>(x == asc[i]) <span class="keyword">return</span>(abc[i]);</div><div class="line">	&#125;</div><div class="line">&#125;<span class="comment">//密文还原操作；</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, keyy+<span class="number">1</span>, mi+<span class="number">1</span>);</div><div class="line">	<span class="comment">//直接将字符串输入到char数组中，从下标1开始存储；</span></div><div class="line">	len = <span class="built_in">strlen</span>(mi + <span class="number">1</span>); lenk = <span class="built_in">strlen</span>(keyy + <span class="number">1</span>);</div><div class="line">	<span class="comment">//strlen需使用头文件&lt;cstring&gt;；</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i ++) &#123;</div><div class="line">		key[i] = keyy[cnt];</div><div class="line">		<span class="keyword">if</span>(cnt == lenk) cnt = <span class="number">1</span>;</div><div class="line">		<span class="keyword">else</span> cnt ++;</div><div class="line">	&#125;<span class="comment">//将密钥循环存入数组，用于后来的还原明文操作；</span></div><div class="line">	</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) &#123;</div><div class="line">		abc[i] = <span class="string">'a'</span> + i - <span class="number">1</span>;	</div><div class="line">	&#125;<span class="comment">//将26位字母按字典序存入；</span></div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</div><div class="line">		<span class="keyword">if</span>(mi[i] &lt; <span class="number">97</span>) &#123;</div><div class="line">			flag[i] = <span class="number">1</span>;</div><div class="line">			mi[i] += <span class="number">32</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(key[i] &lt; <span class="number">97</span>) key[i] += <span class="number">32</span>;</div><div class="line">	&#125;<span class="comment">//大小写转换；</span></div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</div><div class="line">		light[i] = solve(mi[i], key[i]);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</div><div class="line">		<span class="keyword">if</span>(flag[i] == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%c"</span>, light[i] - <span class="number">32</span>);<span class="comment">//还原大写字母；</span></div><div class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%c"</span>, light[i]);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NOIP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「统计」离散化+Map]]></title>
      <url>/2017/10/25/%E3%80%8C%E7%BB%9F%E8%AE%A1%E3%80%8D%E7%A6%BB%E6%95%A3%E5%8C%96+Map/</url>
      <content type="html"><![CDATA[<p>  给定N个数，有M个询问。每次询问一段区间内有没有出现过Xi这个数。</p>
<a id="more"></a>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行一个整数N。<br>第二行N个正整数表示给定的N个数。<br>第三行一个整数M。<br>以下M行每行三个整数li，ri和Xi；表示询问区间是[li, ri]，询问数字是Xi。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每一次询问，输出一个字符。0表示没出现，1表示出现了。</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">5</div><div class="line">1234567 666666 3141593 666666 4343434</div><div class="line">5</div><div class="line">1 5 3141593</div><div class="line">1 5 578202</div><div class="line">2 4 666666</div><div class="line">4 4 7135610</div><div class="line">1 1 1234567</div></pre></td></tr></table></figure>
<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><pre><code>10101
</code></pre><h4 id="数据说明"><a href="#数据说明" class="headerlink" title="数据说明"></a>数据说明</h4><p>40%的数据满足：<code>N≤1000，M≤10001</code></p>
<p>100%的数据满足：<code>N≤10e9，M≤10e5，Xi≤10e9</code></p>
<hr>
<p>这道题有很多种解法，在这里介绍一个用map离散化的做法；其实数据够良心，直接for循环打暴力也可以得到40分的（亲测）；</p>
<p>用map（stl）储存数据，以数字为标志，再开一个vector数组存该数据出现过的位置，直接看位置数据内是否有存在所输入查询范围内的个体；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, m, l, r, x, y;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> res = <span class="number">0</span>; <span class="keyword">int</span> flag = <span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span>(ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) &#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>) flag = <span class="number">-1</span>; ch = getchar();&#125;</div><div class="line">	<span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;res = res * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = getchar();&#125;</div><div class="line">	<span class="keyword">return</span> (res * flag);</div><div class="line">&#125;</div><div class="line"><span class="comment">//高天宇快读；</span></div><div class="line"></div><div class="line"><span class="built_in">map</span> &lt; <span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; mapp;</div><div class="line"><span class="comment">//用int型映射一个int类型的vector；</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapp[x].size(); i++) &#123;</div><div class="line">		<span class="keyword">if</span>(mapp[x][i] &gt;= l &amp;&amp; mapp[x][i] &lt;= r) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	freopen(<span class="string">"statistic.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">	freopen(<span class="string">"statistic.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</div><div class="line">	n = read();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">		y = read();</div><div class="line">		mapp[y].push_back(i);</div><div class="line">	&#125;</div><div class="line">	m = read();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">		l = read(); r = read(); x = read();</div><div class="line">		<span class="keyword">if</span>(query(l, r, x)) <span class="built_in">printf</span>(<span class="string">"1"</span>);</div><div class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"0"</span>);</div><div class="line">	&#125;</div><div class="line">	fclose(<span class="built_in">stdin</span>);</div><div class="line">	fclose(<span class="built_in">stdout</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> STL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「codevs1073」并查集]]></title>
      <url>/2017/10/22/1073/</url>
      <content type="html"><![CDATA[<p><a href="http://codevs.cn/problem/1073/" target="_blank" rel="external">题目链接</a></p>
<p>若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。 规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。</p>
<a id="more"></a>
<h4 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h4><p>第一行：三个整数<strong>n,m,p，（n&lt;=5000,m&lt;=5000,p&lt;=5000）</strong>，分别表示有n个人，m个亲戚关系，询问p对亲戚关系。 以下m行：每行两个数Mi，Mj，<strong>1&lt;=Mi，Mj&lt;=N</strong>，表示Ai和Bi具有亲戚关系。 接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。</p>
<h4 id="输出描述-Output-Description"><a href="#输出描述-Output-Description" class="headerlink" title="输出描述 Output Description"></a>输出描述 Output Description</h4><p>P行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。</p>
<h4 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">6 5 3</div><div class="line"></div><div class="line">1 2</div><div class="line"></div><div class="line">1 5</div><div class="line"></div><div class="line">3 4</div><div class="line"></div><div class="line">5 2</div><div class="line"></div><div class="line">1 3</div><div class="line"></div><div class="line">1 4</div><div class="line"></div><div class="line">2 3</div><div class="line"></div><div class="line">5 6</div></pre></td></tr></table></figure>
<h4 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Yes</div><div class="line"></div><div class="line">Yes</div><div class="line"></div><div class="line">No</div></pre></td></tr></table></figure>
<p>并查集裸题，就当给dalao递板子了，虽然我比较弱，还是说一下自己的理解；其实并查集呢，我们就把它想象成一棵树，存在只有自己一个节点的树，也存在拥有多个节点的树，只要是连通，我们就说他们位于同一个树中，合并并查集呢，就是将两棵树的树根连接在一起咯；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> res = <span class="number">0</span>; <span class="keyword">int</span> flag = <span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span>(ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>) flag = <span class="number">-1</span>; ch = getchar();&#125;</div><div class="line">	<span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;res = res * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = getchar();&#125;</div><div class="line">	<span class="keyword">return</span> (res * flag);</div><div class="line">&#125;</div><div class="line"><span class="comment">//高天宇的快读，大家可以拿去用；</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> n, m, p;</div><div class="line"><span class="keyword">int</span> father[<span class="number">5000</span> + <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> father[x] == x ? x : father[x] = find(father[x]);</div><div class="line">&#125;</div><div class="line"><span class="comment">//寻找父亲（根节点）的操作；</span></div><div class="line"><span class="comment">//路径压缩，回溯的时候就顺带把父亲们直接连接在根节点上，那么节点们寻找根节点的路径</span></div><div class="line"><span class="comment">//就变短了，所以称为路径压缩；</span></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> r1 = find(x); <span class="keyword">int</span> r2 = find(y);</div><div class="line">	<span class="keyword">if</span>(r1 == r2) <span class="keyword">return</span>;</div><div class="line">	<span class="keyword">else</span> father[r1] = r2;</div><div class="line">&#125;</div><div class="line"><span class="comment">//合并操作；如果不是同一个父亲（根节点），则把两棵子树通过各自的根节点连在一起；</span></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> find(x) == find(y) ? <span class="literal">true</span> : <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//判断是不是同一个父亲；</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	n = read(); m = read(); p = read();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) father[i] = i;</div><div class="line">    <span class="comment">//千万别忘了初始化！！！</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</div><div class="line">		<span class="keyword">int</span> x = read(); <span class="keyword">int</span> y = read();</div><div class="line">		merge(x, y);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; ++ i) &#123;</div><div class="line">		<span class="keyword">int</span> x1 = read(); <span class="keyword">int</span> x2 = read();</div><div class="line">		<span class="keyword">if</span>(judge(x1, x2)) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</div><div class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[字符串STL]]></title>
      <url>/2017/10/22/%E5%AD%97%E7%AC%A6%E4%B8%B2STL/</url>
      <content type="html"><![CDATA[<p>参考 （侵权必删）： <a href="http://www.360doc.com/content/10/1006/18/1704901_58868298.shtml" target="_blank" rel="external">http://www.360doc.com/content/10/1006/18/1704901_58868298.shtml</a></p>
<p><a href="http://blog.csdn.net/f_c_g_/article/details/51228909" target="_blank" rel="external">http://blog.csdn.net/f_c_g_/article/details/51228909</a></p>
<p>dalao们总结的够好了， 我就做一个传播者咯(ง •_•)ง<br><a id="more"></a>          </p>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> STL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「codevs2370」LCA-倍增]]></title>
      <url>/2017/10/22/2370/</url>
      <content type="html"><![CDATA[<p><a href="http://codevs.cn/problem/2370/" target="_blank" rel="external">题目链接</a></p>
<p>  小机房有棵焕狗种的树，树上有N个节点，节点标号为<strong>0到N-1</strong>，有两只虫子名叫飘狗和大吉狗，分居在两个不同的节点上。有一天，他们想爬到一个节点上去搞基，但是作为两只虫子，他们不想花费太多精力。已知从某个节点爬到其父亲节点要花费<strong> c</strong> 的能量（从父亲节点爬到此节点也相同），他们想找出一条花费精力最短的路，以使得搞基的时候精力旺盛，他们找到你要你设计一个程序来找到这条路，要求你告诉他们最少需要花费多少精力</p>
<a id="more"></a>
<h4 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h4><p>第一行一个n，接下来n-1行每一行有三个整数u，v, c 。表示节点 u 爬到节点 v 需要花费 c 的精力。<br>第n+1行有一个整数m表示有m次询问。接下来m行每一行有两个整数 u ，v 表示两只虫子所在的节点<br>输出描述 Output Description<br>一共有m行，每一行一个整数，表示对于该次询问所得出的最短距离。</p>
<h4 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">3</div><div class="line"></div><div class="line">1 0 1</div><div class="line"></div><div class="line">2 0 1</div><div class="line"></div><div class="line">3</div><div class="line"></div><div class="line">1 0</div><div class="line"></div><div class="line">2 0</div><div class="line"></div><div class="line">1 2</div></pre></td></tr></table></figure>
<h4 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line"></div><div class="line">1</div><div class="line"></div><div class="line">2</div></pre></td></tr></table></figure>
<h4 id="数据范围及提示-Data-Size-amp-Hint"><a href="#数据范围及提示-Data-Size-amp-Hint" class="headerlink" title="数据范围及提示 Data Size &amp; Hint"></a>数据范围及提示 Data Size &amp; Hint</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1&lt;=n&lt;=50000， 1&lt;=m&lt;=75000， 0&lt;=c&lt;=1000</div></pre></td></tr></table></figure>
<p>这是一道lca（最近公共祖先）的裸题， 我们只需要求出两点到根节点的距离和， 再用 距离和 减去 两次 lca到根节点的距离，即为两点间的最短路径长度；</p>
<p>那么lca要怎么求呢？ 我们一起来看一看！ 首先我们需要定义一个数组depth[i]记录i点的深度（通过函数dfs求出）；一个二维数组father[x][i]记录点x向上2的i次方的祖先（通过函数pow_init求出）；已知x，y求lca的方法：看x,y两点是否为同一深度，我们移动较深的点直至两点位于同一深度，然后从2的i次方开始跳（i为 上跳2的i次方 最大不超过根节点 时i的值），i递减，如果跳到同一点，则不跳（防止跳过lca到了别的点），最后我们肯定会走到离lca深度为1的点，再跳一个深度即可！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> max(x, y) ((x) &gt; (y) ? (x) : (y))</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50000</span> + <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></div><div class="line">	<span class="keyword">int</span> to, w, next;</div><div class="line">&#125; edge[MAXN * <span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, m, num, logn, deep;</div><div class="line"><span class="keyword">int</span> head[MAXN], depth[MAXN], dis[MAXN];</div><div class="line"><span class="keyword">int</span> father[MAXN][<span class="number">20</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</div><div class="line">	edge[++num].to = to;</div><div class="line">	edge[num].w = w;</div><div class="line">	edge[num].next = head[from];</div><div class="line">	head[from] = num;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> cur)</span> </span>&#123; <span class="comment">// x是点， cur是点的深度；</span></div><div class="line">	depth[x] = cur;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next) &#123; <span class="comment">// 遍历；</span></div><div class="line">		<span class="keyword">if</span>(depth[edge[i].to]) <span class="keyword">continue</span>; <span class="comment">// 如果这个点是父亲；</span></div><div class="line">		father[edge[i].to][<span class="number">0</span>] = x;</div><div class="line">		dis[edge[i].to] = edge[i].w + dis[x];<span class="comment">//预处理树的前缀和；</span></div><div class="line">		deep = max(deep, depth[x]); <span class="comment">// 求树的深度；</span></div><div class="line">		dfs(edge[i].to, depth[x] + <span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pow_init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span> &lt;&lt; j) &lt;= deep;j ++) &#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123;</div><div class="line">			father[i][j] = father[father[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</div><div class="line">            <span class="comment">//倍增的运用，dalao自行脑补或者画张图，一张图很明了的， 倍增：这样可以借助之前的点做跳板，如果想暴力一个一个地枚举也可以，但是就比较慢了；</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//遍历出父亲；</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(depth[x] &lt; depth[y]) <span class="built_in">std</span>::swap(x, y);</div><div class="line">	<span class="keyword">if</span>(depth[x] != depth[y]) &#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = logn; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">			<span class="keyword">if</span>(depth[x] - (<span class="number">1</span> &lt;&lt; i) &gt;= depth[y]) &#123;</div><div class="line">            <span class="comment">//如果没有跳多； 就跳！；</span></div><div class="line">				x = father[x][i];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</div><div class="line">   <span class="comment">//如果跳到同一深度就是同一个点，说明两点在同一路径上面，找到了！；</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = logn; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">		<span class="keyword">if</span>(father[x][i] == father[y][i]) <span class="keyword">continue</span>;</div><div class="line">		x = father[x][i]; y = father[y][i];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> father[x][<span class="number">0</span>];<span class="comment">//再向上一部</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line">		<span class="keyword">int</span> u, v, c;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;c);</div><div class="line">		add_edge(u, v, c);</div><div class="line">		add_edge(v, u, c);</div><div class="line">	&#125;</div><div class="line">	dfs(<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">	pow_init(n);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= deep; i++) logn = i;logn++;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">		<span class="keyword">int</span> x, y;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</div><div class="line">		<span class="keyword">int</span> r = LCA(x, y);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dis[x] + dis[y] - dis[r] * <span class="number">2</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vector-不定长数组]]></title>
      <url>/2017/10/20/Vector-%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<p>不定长数组<strong>vector</strong>是一个<strong>stl</strong>库中的容器；类似于数组，因其有不定长的特性，故在<strong>一些情况下</strong>可以<strong>节省空间</strong>；</p>
<p>调用vector需要挂头文件<code>&lt;vector&gt;</code>;<br>还需要注明<code>std</code>；</p>
<a id="more"></a>
<h4 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h4><p>·我们先来定义一个int型的vector数组： <code>vector &lt;int&gt; vec</code></p>
<p>·新增元素i至数组尾部：<code>vec.push_back(i)</code></p>
<p>·删除数组尾部的元素：<code>vec.pop_back()</code></p>
<p>·回传vector第一个元素的值：<code>vec.front()</code></p>
<p>·回传vector数组最尾部元素的值：<code>vec.back()</code></p>
<p>·存取索引值为i的元素值：<code>vec[i] 或者 vec.(i)</code>//前提是位置已开出</p>
<p>·清空vector数组内的元素：<code>vec.clear()</code></p>
<p>·判断数组是否为空(如果为空，返回true)：<code>vec.empty()</code> </p>
<p>·获取vector数组目前拥有的元素个数：<code>vec.size()</code></p>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> STL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「codevs1047」DP + 搜索]]></title>
      <url>/2017/10/19/1047/</url>
      <content type="html"><![CDATA[<p><a href="http://codevs.cn/problem/1047/" target="_blank" rel="external">题目链接</a></p>
<p>  给定一个信封，最多只允许粘贴N张邮票，计算在给定K（N+K≤40）种邮票的情况下（假定所有的邮票数量都足够），如何设计邮票的面值，能得到最大值MAX，使在1～MAX之间的每一个邮资值都能得到。</p>
<p>例如，N=3，K=2，如果面值分别为1分、4分，则在1分～6分之间的每一个邮资值都能得到（当然还有8分、9分和12分）；如果面值分别为1分、3分，则在1分～7分之间的每一个邮资值都能得到。可以验证当N=3，K=2时，7分就是可以得到的连续的邮资最大值，所以MAX=7，面值分别为1分、3分。</p>
<a id="more"></a>
<h4 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h4><pre><code>N和K
</code></pre><h4 id="输出描述-Output-Description"><a href="#输出描述-Output-Description" class="headerlink" title="输出描述 Output Description"></a>输出描述 Output Description</h4><p>每种邮票的面值，连续最大能到的面值数。数据保证答案唯一。</p>
<h4 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h4><pre><code>3 2
</code></pre><h4 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h4><pre><code>1 3
MAX=7
</code></pre><p>看过题面， 我们发现这好像可以通过搜索来AC， 但又要用到一定的动归思想，Go for it!</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> max(x, y) ((x) &gt; (y) ? (x) : (y))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> min(x, y) ((x) &lt; (y) ? (x) : (y))</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e8</span>;</div><div class="line"><span class="keyword">int</span> n, k, ans, sum; </div><div class="line"><span class="keyword">int</span> a[<span class="number">1000</span> + <span class="number">5</span>], dp[<span class="number">1000</span> + <span class="number">5</span>]， b[<span class="number">1000</span> + <span class="number">5</span>];</div><div class="line"><span class="comment">//b数组用来储存结果， 因为a数组经过了多次变动；</span></div><div class="line"><span class="comment">//a数组用来储存起始数据；</span></div><div class="line"><span class="comment">//dp[i]达到i值最少需要多少张牌</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) &#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>) flag = <span class="number">-1</span>; ch = getchar();&#125;</div><div class="line">	<span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;res = res * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = getchar();&#125;</div><div class="line">	<span class="keyword">return</span> (res * flag);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">()</span> </span>&#123;</div><div class="line">	dp[<span class="number">1</span>] = <span class="number">1</span>; <span class="keyword">int</span> i; <span class="comment">//赋初值</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">2</span>; ; i++) &#123;</div><div class="line">		dp[i] = INF;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k &amp;&amp; i - a[j] &gt;= <span class="number">0</span>; j++) &#123;</div><div class="line">			dp[i] = min(dp[i], dp[i - a[j]] + <span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">        <span class="comment">//j &lt;= k (j 是种类， 所以一定是&lt;=K)</span></div><div class="line">        <span class="comment">//i - a[j] &gt;= 0; 我们可以不选（dp[0] = 0）,但所选择的数值肯定是不能大于i的；</span></div><div class="line">		<span class="keyword">if</span> (dp[i] &gt; n) <span class="keyword">break</span>;</div><div class="line">        <span class="comment">//用的数量已经大于最大可选数量；</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (i - <span class="number">1</span> &gt; ans) &#123;<span class="comment">//因为i++，所以其实大1，故要减一，让新结果与旧的结果相比较；</span></div><div class="line">		ans = i - <span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</div><div class="line">		    b[i] = a[i];   </div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 以第几种面值为参数</span></div><div class="line">	<span class="keyword">if</span>(x == k + <span class="number">1</span>) &#123;</div><div class="line">		DP(); <span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = a[x - <span class="number">1</span>] + <span class="number">1</span>; i &lt;= a[x - <span class="number">1</span>] * n + <span class="number">1</span>; i++) &#123;</div><div class="line">		a[x] = i;</div><div class="line">		dfs(x + <span class="number">1</span>); <span class="comment">//一颗树形结构，不断向下分支，再return上去；</span></div><div class="line">	&#125;</div><div class="line">    <span class="comment">//a[x - 1] + 1 加上新数值最起码大1；</span></div><div class="line">    <span class="comment">//a[x - 1] * n + 1 加1保证其连续性， 加2的话就不再连续了；</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	n = read(); k = read();</div><div class="line">	a[<span class="number">1</span>] = <span class="number">1</span>; ans = k;</div><div class="line">	dfs(<span class="number">2</span>);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) <span class="built_in">cout</span> &lt;&lt; b[i] &lt;&lt; <span class="string">" "</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"MAX="</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP - 搜索 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「codevs3027」序列DP]]></title>
      <url>/2017/10/18/3027/</url>
      <content type="html"><![CDATA[<p><a href="http://codevs.cn/problem/3027/" target="_blank" rel="external">题目链接</a></p>
<p>  数轴上有n条线段，线段的两端都是整数坐标，坐标范围在0~1000000，每条线段有一个价值，请从n条线段中挑出若干条线段，使得这些线段两两不覆盖（端点可以重合）且线段价值之和最大。</p>
<pre><code>n&lt;=1000
</code></pre><a id="more"></a>
<h4 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h4><p>第一行一个整数n，表示有多少条线段。</p>
<p>接下来n行每行三个整数, ai bi ci，分别代表第i条线段的左端点ai，右端点bi（保证左端点&lt;右端点）和价值ci。</p>
<p>输出描述 Output Description<br>输出能够获得的最大价值</p>
<h4 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3</div><div class="line"></div><div class="line">1 2 1</div><div class="line"></div><div class="line">2 3 2</div><div class="line"></div><div class="line">1 3 4</div></pre></td></tr></table></figure>
<h4 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h4><pre><code>4
</code></pre><h4 id="数据范围及提示-Data-Size-amp-Hint"><a href="#数据范围及提示-Data-Size-amp-Hint" class="headerlink" title="数据范围及提示 Data Size &amp; Hint"></a>数据范围及提示 Data Size &amp; Hint</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">对于40%的数据，n≤10；</div><div class="line"></div><div class="line">对于100%的数据，n≤1000；</div><div class="line"></div><div class="line">0&lt;=ai,bi&lt;=1000000</div><div class="line"></div><div class="line">0&lt;=ci&lt;=1000000</div></pre></td></tr></table></figure>
<p>首先对这道题展开分析，可以看出这是一道DP题，但是我们怎么做呢？我们首先建立一个结构体将每条线段的左端点和右端点及价值储存，按照<strong>右端点</strong>进行sort操作（<strong>用来保证左边尽可能持有更多的边</strong>）； 建立一个数组f[i],用来储存到<br>编号为i的这条边我们所拥有的最大价值；遍历求出发f[i]，然后max函数找到最大值；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> max(x, y) ((x) &gt; (y) ? (x) : (y))</span></div><div class="line"><span class="comment">//这里将x，y单独加括号的原因是防止三目运算时参数x或y传的是一个式子；</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, sum, f[<span class="number">1000</span> + <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) &#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>) flag = <span class="number">-1</span>; ch = getchar();&#125;</div><div class="line">	<span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;res = res * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = getchar();&#125;</div><div class="line">	<span class="keyword">return</span> (res * flag);</div><div class="line">&#125;<span class="comment">//快读（高天宇） 只能读数，不可读字符</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></div><div class="line">	<span class="keyword">int</span> l, r, c;</div><div class="line">	Line(<span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>) : l(l), r(r), c(c) &#123;&#125;</div><div class="line">&#125;line[<span class="number">1000</span> + <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Line a, Line b)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> a.r &lt; b.r;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	n = read();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">		line[i].l = read();</div><div class="line">		line[i].r = read();</div><div class="line">		line[i].c = read();</div><div class="line">	&#125;</div><div class="line">	sort(line + <span class="number">1</span>, line + n + <span class="number">1</span>, cmp);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;  i &lt;= n; i++) f[i] = line[i].c;</div><div class="line">    <span class="comment">//赋值操作一定要加在sort之后； 因为sort会改变line[i].c的位置；</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++) &#123;</div><div class="line">			<span class="keyword">if</span>(line[j].r &lt;= line[i].l) &#123;</div><div class="line">				f[i] = max(f[i], f[j] + line[i].c);<span class="comment">//转移方程</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">		sum = max(sum, f[i]);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, sum);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「codevs1078」Kruskal]]></title>
      <url>/2017/10/17/1078/</url>
      <content type="html"><![CDATA[<p><a href="http://codevs.cn/problem/1078/" target="_blank" rel="external">题目链接</a></p>
<p>  农民约翰被选为他们镇的镇长！他其中一个竞选承诺就是在镇上建立起互联网，并连接到所有的农场。当然，他需要你的帮助。 约翰已经给他的农场安排了一条高速的网络线路，他想把这条线路共享给其他农场。为了使花费最少，他想铺设最短的光纤去连接所有的农场。 你将得到一份各农场之间连接费用的列表，你必须找出能连接所有农场并所用光纤最短的方案。 每两个农场间的距离不会超过100000</p>
<a id="more"></a>
<h4 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h4><p>第一行： 农场的个数，<strong>N（3&lt;=N&lt;=100）</strong>。</p>
<p>第二行..结尾: 接下来的行包含了一个N*N的矩阵,表示每个农场之间的距离。理论上，他们是N行，每行由N个用空格分隔的数组成，实际上，他们每行限制在80个字符以内，因此，某些行会紧接着另一些行。当然，对角线将会是0，因为线路从第i个农场到它本身的距离在本题中没有意义。</p>
<h4 id="输出描述-Output-Description"><a href="#输出描述-Output-Description" class="headerlink" title="输出描述 Output Description"></a>输出描述 Output Description</h4><p>只有一个输出，是连接到每个农场的光纤的最小长度和。</p>
<h4 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">4</div><div class="line"></div><div class="line">0  4  9 21</div><div class="line"></div><div class="line">4  0  8 17</div><div class="line"></div><div class="line">9  8  0 16</div><div class="line"></div><div class="line">21 17 16  0</div></pre></td></tr></table></figure>
<h4 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h4><pre><code>28
</code></pre><p>这是一道最小生成树模板题，最小生成树算法的巧妙之处在于它使用了<strong>并查集</strong>和<strong>贪心</strong>的相关知识；首先我们将边读入，然后呢，将编权从小到大排序；按照边权从小到大的顺序依次加边，每加入一条边，将其两端点加入并查集内，直到所有的边都加入并查集内时，最小生成树便生成了！<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt; std::endl</span></div><div class="line"><span class="comment">//用于debug的一个操作，可忽略；</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, m;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></div><div class="line">	<span class="keyword">int</span> s, t, w;</div><div class="line">&#125; edge[MAXN * MAXN];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> a.w &lt; b.w;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> father[MAXN];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> x == father[x] ? x : father[x] = find(father[x]);</div><div class="line">&#125;</div><div class="line"><span class="comment">//并查集find操作；</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="comment">//res用于存最小总权值；</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) father[i] = i;</div><div class="line">    <span class="comment">//并查集初始化；</span></div><div class="line">	<span class="built_in">std</span>::sort(edge + <span class="number">1</span>, edge + m + <span class="number">1</span>, cmp);</div><div class="line">    <span class="comment">//将边权排序；</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">		<span class="keyword">int</span> fx = find(edge[i].s), fy = find(edge[i].t);</div><div class="line">		<span class="keyword">if</span> (fx != fy) &#123;</div><div class="line">			father[fx] = fy;</div><div class="line">			res += edge[i].w;</div><div class="line">		&#125;</div><div class="line">        <span class="comment">//将边加入；</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</div><div class="line">			edge[++m].s = i, edge[m].t = j;</div><div class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;edge[m].w);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, kruskal());</div><div class="line">			</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「codevs1557」Dijkstra]]></title>
      <url>/2017/10/15/1557/</url>
      <content type="html"><![CDATA[<p><a href="http://codevs.cn/problem/1557/" target="_blank" rel="external">题目链接</a></p>
<p>   德克萨斯纯朴的民眾们这个夏天正在遭受巨大的热浪！！！他们的德克萨斯长角牛吃起来不错，可是他们并不是很擅长生產富含奶油的乳製品。Farmer John此时以先天下之忧而忧，后天下之乐而乐的精神，身先士卒地承担起向德克萨斯运送大量的营养冰凉的牛奶的重任，以减轻德克萨斯人忍受酷暑的痛苦。</p>
<p>FJ已经研究过可以把牛奶从威斯康星运送到德克萨斯州的路线。这些路线包括起始点和终点先一共经过T <strong>(1 &lt;= T &lt;= 2,500)</strong>个城镇，方便地标号為1到<strong>T</strong>。除了起点和终点外地每个城镇由两条双向道路连向至少两个其它地城镇。每条道路有一个通过费用（包括油费，过路费等等）。</p>
<p>给定一个地图，包含C<strong> (1 &lt;= C &lt;= 6,200)</strong>条直接连接2个城镇的道路。每条道路由道路的起点Rs，终点Re <strong>(1 &lt;= Rs &lt;= T; 1 &lt;= Re &lt;= T)</strong>，和花费<strong>(1 &lt;= Ci &lt;= 1,000)</strong>组成。求从起始的城镇Ts <strong>(1 &lt;= Ts &lt;= T)</strong>到终点的城镇Te<strong>(1 &lt;= Te &lt;= T)</strong>最小的总费用。</p>
<a id="more"></a>
<h4 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h4><p>第一行: 4个由空格隔开的整数:<code>T, C, Ts, Te</code></p>
<p>第2到第<code>C+1</code>行: 第<code>i+1</code>行描述第i条道路。有3个由空格隔开的整数:<code>Rs, Re和Ci</code></p>
<h4 id="输出描述-Output-Description"><a href="#输出描述-Output-Description" class="headerlink" title="输出描述 Output Description"></a>输出描述 Output Description</h4><p>一个单独的整数表示从Ts到Te的最小总费用。数据保证至少存在一条道路。</p>
<h4 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">7 11 5 4</div><div class="line"></div><div class="line">2 4 2</div><div class="line"></div><div class="line">1 4 3</div><div class="line"></div><div class="line">7 2 2</div><div class="line"></div><div class="line">3 4 3</div><div class="line"></div><div class="line">5 7 5</div><div class="line"></div><div class="line">7 3 3</div><div class="line"></div><div class="line">6 1 1</div><div class="line"></div><div class="line">6 3 4</div><div class="line"></div><div class="line">2 4 3</div><div class="line"></div><div class="line">5 6 3</div><div class="line"></div><div class="line">7 2 1</div></pre></td></tr></table></figure>
<h4 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">7</div></pre></td></tr></table></figure>
<h4 id="数据范围及提示-Data-Size-amp"><a href="#数据范围及提示-Data-Size-amp" class="headerlink" title="数据范围及提示 Data Size &amp;"></a>数据范围及提示 Data Size &amp;</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hint</div><div class="line">5-&gt;6-&gt;1-&gt;4 (3 + 1 + 3)</div></pre></td></tr></table></figure>
<p>本题是一道单源最短路<strong>Dijkstra</strong>算法的模板题，让我们一起探讨吧！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2500</span> + <span class="number">5</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">12400</span> + <span class="number">5</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3</span>;</div><div class="line"><span class="keyword">int</span> head[MAXN], dist[MAXN],  n, m, num, start, end;</div><div class="line"><span class="comment">//head数组记录存的是在这条边被加入之前的最后一条边（边表的一端）；</span></div><div class="line"><span class="comment">//dist数组储存起点到这个点的距离</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></div><div class="line">	<span class="keyword">int</span> from, to, next, w;</div><div class="line">&#125;edge[MAXM];</div><div class="line"><span class="comment">//用于建图</span></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</div><div class="line">	edge[++num].from = from;</div><div class="line">	edge[num].to = to;</div><div class="line">	edge[num].w = w;</div><div class="line">	edge[num].next = head[from];</div><div class="line">    <span class="comment">//next存上一条边（整条边）</span></div><div class="line">	head[from] = num;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dist</span> &#123;</span></div><div class="line">	<span class="keyword">int</span> x, dist;</div><div class="line">	Dist(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> dist = inf) : x(x), dist(dist) &#123;&#125;</div><div class="line">    <span class="comment">//结构体初始化</span></div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(Dist l, Dist r)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> l.dist &gt; r.dist;</div><div class="line">	&#125;</div><div class="line">    <span class="comment">//重载运算符：按从小到大排序；</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">priority_queue &lt;Dist, <span class="built_in">vector</span>&lt;Dist&gt;, Dist&gt; que;</div><div class="line"><span class="comment">//建立一个以Dist为元素的不定长数组；</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = inf;</div><div class="line">	dist[start] = <span class="number">0</span>;</div><div class="line">	que.push(Dist(start, <span class="number">0</span>));</div><div class="line">    <span class="comment">//初始化操作；</span></div><div class="line">	<span class="keyword">while</span>(!que.empty()) &#123;</div><div class="line">    <span class="comment">//while(!que.empty())  如果队列为空返回一  取非之后返回零；也就是说当队列不为空时；</span></div><div class="line">		Dist tmp = que.top();</div><div class="line">		que.pop();</div><div class="line">		<span class="keyword">if</span>(tmp.dist != dist[tmp.x]) <span class="keyword">continue</span>;</div><div class="line">       <span class="comment">//因为队列里面的数是不断更新的，如果不等于，说明这个点比较旧了，然而我们需要的其实是最新的点，所以就把它continue掉；</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = head[tmp.x]; j; j = edge[j].next) &#123;</div><div class="line">			<span class="keyword">if</span>(dist[edge[j].to] &gt; dist[tmp.x] + edge[j].w) &#123;</div><div class="line">				dist[edge[j].to] = dist[tmp.x] + edge[j].w;</div><div class="line">				que.push(Dist(edge[j].to, dist[edge[j].to]));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">        <span class="comment">//遍历求距；</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> dist[end];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;start, &amp;end);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</div><div class="line">		<span class="keyword">int</span> x, y, z;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</div><div class="line">		add_edge(x, y, z);</div><div class="line">		add_edge(y, x, z);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, dijkstra());</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
