<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <url>/2018/10/23/%E5%AF%BB%E6%89%BE%E9%81%93%E8%B7%AF/</url>
      <content type="html"><![CDATA[<h1 id="寻找道路"><a href="#寻找道路" class="headerlink" title="寻找道路"></a>寻找道路</h1><p>标签（空格分隔）： 未分类</p>
<hr>
<p>在有向图 G 中，每条边的长度均为 1，现给定起点和终点，请你在图中找一条从起点到终点的路径，该路径满足以下条件：</p>
<ul>
<li>路径上的所有点的出边所指向的点都直接或间接与终点连通。 在满足条件1的情况下使路径最短。</li>
<li>注意：图 G 中可能存在重边和自环，题目保证终点没有出边。</li>
</ul>
<p>请你输出符合条件的路径的长度。</p>
<p><strong>输入输出格式</strong><br><strong>输入格式：</strong></p>
<p>第一行有两个用一个空格隔开的整数 n 和 m，表示图有 n 个点和 m 条边。</p>
<p>接下来的 m 行每行 2 个整数 x,y，之间用一个空格隔开，表示有一条边从点 x 指向点y。</p>
<p>最后一行有两个用一个空格隔开的整数 s,t，表示起点为 s，终点为 t。</p>
<p><strong>输出格式</strong>：</p>
<p>输出只有一行，包含一个整数，表示满足题目描述的最短路径的长度。如果这样的路径不存在，输出−1。</p>
<p><strong>输入输出样例</strong><br><strong>输入样例#1：</strong> </p>
<blockquote>
<p>3 2</p>
<p>1 2</p>
<p>2 1</p>
<p>1 3</p>
</blockquote>
<p><strong>输出样例#1：</strong> </p>
<blockquote>
<p>-1</p>
</blockquote>
<p><strong>输入样例#2：</strong> </p>
<blockquote>
<p>6 6</p>
<p>1 2</p>
<p>1 3</p>
<p>2 6</p>
<p>2 5</p>
<p>4 5</p>
<p>3 4</p>
<p>1 5</p>
</blockquote>
<p><strong>输出样例#2：</strong> </p>
<blockquote>
<p>3</p>
</blockquote>
<p><strong>说明</strong><br>解释1：</p>
<p>如上图所示，箭头表示有向道路，圆点表示城市。起点11与终点33不连通，所以满足题目描述的路径不存在，故输出−1 。</p>
<p>解释2：</p>
<p>如上图所示，满足条件的路径为1- &gt;3- &gt;4- &gt;5。注意点2不能在答案路径中，因为点2连了一条边到点6，而点6不与终点5连通</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Bellman Ford]]></title>
      <url>/2018/07/26/Bellman%20Ford/</url>
      <content type="html"><![CDATA[<p>Bellman Ford同样是一种单源最短路算法，它的优秀之出在于它可以处理带有负边权的图，我们先来看看核心代码：</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n - <span class="number">1</span>; k ++) &#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">		<span class="keyword">if</span>(dist[edge[i].to] &gt; dist[edge[i].from] + edge[i].w) &#123;</div><div class="line">			dist[edge[i].to] = dist[edge[i].from] + edge[i].w;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码中，外循环一共循环了n - 1次（n为顶点的个数），内循环循环了m次（m为边的个数），dist为源点到其余各点的距离。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(dist[edge[i].to] &gt; dist[edge[i].from] + edge[i].w) &#123;</div><div class="line">			dist[edge[i].to] = dist[edge[i].from] + edge[i].w;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>上面这两行代码的意思是，看看能否通过第i条边，使得源点到第i条边的终点的距离变短。这其实与dijkstra的<strong>松弛</strong>操作是一样的。现在我们要把所有的边都松弛一遍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">		<span class="keyword">if</span>(dist[edge[i].to] &gt; dist[edge[i].from] + edge[i].w) &#123;</div><div class="line">			dist[edge[i].to] = dist[edge[i].from] + edge[i].w;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>在第1轮对所有边进行松弛之后，得到的是从源点<strong>只经过一条边</strong>到达其余个顶点的最短路径长度。在第2轮对所有的边进行松弛之后，得到的是从源点<strong>最多经过两条边</strong>到达其余各顶点的最短路径长度。如果进行k轮的话，得到的就是从源点<strong>最多经过k条边</strong>到达其余各顶点的最短路径长度。</p>
<p>我们最多进行<strong>n-1</strong>轮松弛就可以了，因为在一个含n个点的图中，任意两点间的最短路径最多包含n-1条边。</p>
<p><a href="http://codevs.cn/problem/1557/" target="_blank" rel="external">题目链接</a></p>
<p>热浪大家已经很熟悉了，这道题也可以作为<strong>Bellman Ford</strong>算法的模板题，大家可以用这道题来检验自己算法的准确性。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt;std:: endl</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> res = <span class="number">0</span>; <span class="keyword">int</span> flag = <span class="number">1</span>;</div><div class="line">	<span class="keyword">for</span>(; !<span class="built_in">isdigit</span>(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) flag = <span class="number">-1</span>;</div><div class="line">	<span class="keyword">for</span>(; <span class="built_in">isdigit</span>(ch); ch = getchar()) res = (res &lt;&lt; <span class="number">3</span>) + (res &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>;</div><div class="line">	<span class="keyword">return</span> (res * flag);</div><div class="line">&#125;<span class="comment">//快读  需要用到头文件&lt;cctype&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N_max = <span class="number">2500</span> + <span class="number">7</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> M_max = <span class="number">13000</span> + <span class="number">7</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, m, start, end, num;</div><div class="line"><span class="keyword">int</span> dis[N_max];</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></div><div class="line">	<span class="keyword">int</span> from, to, w, next;</div><div class="line">&#125;edge[M_max];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</div><div class="line">	edge[++num].to = to;</div><div class="line">	edge[num].w = w;</div><div class="line">	edge[num].from = from;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BellmanFord</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</div><div class="line">		dis[i] = INF;</div><div class="line">	&#125;</div><div class="line">	dis[start] = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - <span class="number">1</span>; j ++) &#123;</div><div class="line">		<span class="keyword">bool</span> check = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * m; i++) &#123;</div><div class="line">			<span class="keyword">if</span>(dis[edge[i].to] &gt; dis[edge[i].from] + edge[i].w) &#123;</div><div class="line">				dis[edge[i].to] = dis[edge[i].from] + edge[i].w;</div><div class="line">				check = <span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(check == <span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//如果这一轮松弛操作中，如果dis数组没有任何变动，</span></div><div class="line">        那么就可以说明所有点的dis值都已经确定了，便可以退出循环。</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> dis[end];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	n = read(); m = read(); start = read(); end = read();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</div><div class="line">		<span class="keyword">int</span> x, y, z;</div><div class="line">		x = read(); y = read(); z = read();</div><div class="line">		add_edge(x, y, z);</div><div class="line">		add_edge(y, x, z);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * m; i ++) &#123;</div><div class="line">		<span class="keyword">if</span>(dis[edge[i].to] &gt; dis[edge[i].from] + edge[i].w) &#123;</div><div class="line">			<span class="built_in">printf</span>(<span class="string">"fuhuan\n"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="comment">//如果在Bellman Ford跑完后，dis数组仍可以变动，则说明图中存在负环。</span></div><div class="line">	</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, BellmanFord());</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「NOIP2013」积木大赛]]></title>
      <url>/2017/11/06/3288/</url>
      <content type="html"><![CDATA[<p><a href="http://codevs.cn/problem/3288/" target="_blank" rel="external">题目链接</a></p>
<p>春春幼儿园举办了一年一度的“积木大赛”。今年比赛的内容是搭建一座宽度为 n 的大厦，大厦可以看成由 n 块宽度为1的积木组成，第i块积木的最终高度需要是hi。<br>在搭建开始之前，没有任何积木<strong>（可以看成 n 块高度为 0 的积木）</strong>。接下来每次操作，小朋友们可以选择一段连续区间<strong>[L,R]</strong>，然后将第 L 块到第 R 块之间<strong>（含第 L 块和第 R 块）</strong>所有积木的高度分别增加1。<br>小 M 是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。</p>
<a id="more"></a>
<h4 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h4><p>输入包含两行，第一行包含一个整数 n，表示大厦的宽度。<br>第二行包含 n 个整数，第i个整数为hi</p>
<h4 id="输出描述-Output-Description"><a href="#输出描述-Output-Description" class="headerlink" title="输出描述 Output Description"></a>输出描述 Output Description</h4><p>仅一行，即建造所需的最少操作数。</p>
<h4 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">5</div><div class="line">2 3 4 1 2</div></pre></td></tr></table></figure>
<h4 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">5</div></pre></td></tr></table></figure>
<p>由题意可知，我们可以一次搭不间断的一整层（高度为1）；如果模拟的话，要写一大堆东西，占代码量还比较麻烦；那么我们根据每两座楼之间的差值来探索，每有一个差值，就说明出现一个间断，那么就需要多一次操作；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> max(x, y) ((x) &gt; (y) ? (x) : (y))</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> n, h[<span class="number">100005</span>], dec[<span class="number">100005</span>], ans;<span class="comment">//dec数组存储差值；</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> res = <span class="number">0</span>; <span class="keyword">int</span> flag = <span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span>(ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) &#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>) flag = <span class="number">-1</span>; ch = getchar();&#125;</div><div class="line">	<span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;res = res * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = getchar();&#125;</div><div class="line">	<span class="keyword">return</span> (res * flag);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	n = read();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;h[i] = read(); <span class="keyword">if</span>(h[i] &gt; h[i - <span class="number">1</span>]) dec[i] = h[i] - h[i - <span class="number">1</span>];&#125;</div><div class="line">    <span class="comment">//如果比前一座高，那么我们需要多一次操作；如果矮的话，我们之前搭的时候就已经搭完了，不需要再搭了；</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">		ans += dec[i];</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NOIP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「NOIP2012」Vigenère密码]]></title>
      <url>/2017/11/03/1197/</url>
      <content type="html"><![CDATA[<p><a href="http://codevs.cn/problem/1197/" target="_blank" rel="external">题目链接</a></p>
<p>16 世纪法国外交家Blaise de Vigenère设计了一种多表密码加密算法——Vigenère密码。Vigenère 密码的加密解密算法简单易用，且破译难度比较高，曾在美国南北战争中为南军所广泛使用。</p>
<p>在密码学中，我们称需要加密的信息为明文，用 M 表示；称加密后的信息为密文，用C 表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为k。 在Vigenère密码中， 密钥k是一个字母串， k=k1k2…kn。当明文M=m1m2…mn时，得到的密文C=c1c2…cn，其中<strong>ci=mi®ki</strong>，运算®的规则如下表所示：</p>
<p>Vigenère加密在操作时需要注意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1.  ®运算忽略参与运算的字母的大小写，并保持字母在明文 M中的大小写形式；</div><div class="line">2.  当明文M的长度大于密钥k的长度时，将密钥k 重复使用。</div></pre></td></tr></table></figure>
<p>例如，明文M=Helloworld，密钥k=abc 时，密文C=Hfnlpyosnd。</p>
<p><strong>这里题面的表不是很好弄，还请大家点击题目链接看题</strong>；</p>
<a id="more"></a>
<h4 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h4><p>输入共2行。</p>
<p>第一行为一个字符串，表示密钥k，长度不超过100，其中仅包含大小写字母。第二为一个字符串，表示经加密后的密文，长度不超过1000，其中仅包含大小写字母</p>
<h4 id="输出描述-Output-Description"><a href="#输出描述-Output-Description" class="headerlink" title="输出描述 Output Description"></a>输出描述 Output Description</h4><p>输出共1行，一个字符串，表示输入密钥和密文所对应的明文</p>
<h4 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CompleteVictory</div><div class="line"></div><div class="line">Yvqgpxaimmklongnzfwpvxmniytm</div></pre></td></tr></table></figure>
<h4 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Wherethereisawillthereisaway</div></pre></td></tr></table></figure>
<p>NOIP2012 Day1T1, 本题还是比较简单，纯模拟；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> len, lenk, cnt = <span class="number">1</span>;<span class="comment">//len密文长度， lenk密钥长度；</span></div><div class="line"><span class="keyword">char</span> keyy[<span class="number">105</span>], key[<span class="number">1005</span>], mi[<span class="number">1005</span>], light[<span class="number">1005</span>], abc[<span class="number">27</span>], asc[<span class="number">26</span>];</div><div class="line"><span class="comment">//key存储输入的密钥， mi存储输入的密文，light存储明文，abc存储26个英文字母；</span></div><div class="line"><span class="keyword">bool</span> flag[<span class="number">1005</span>];<span class="comment">//用于还原大小写；</span></div><div class="line"><span class="comment">//本题中全部转化为小写字母，方便操作；</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> x, <span class="keyword">char</span> y)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> pos = y - <span class="string">'a'</span>;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) &#123;</div><div class="line">		asc[i] = <span class="string">'a'</span> + pos;</div><div class="line">		<span class="keyword">if</span>(pos == <span class="number">25</span>) pos = <span class="number">0</span>;</div><div class="line">		<span class="keyword">else</span> pos ++; </div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) &#123;</div><div class="line">		<span class="keyword">if</span>(x == asc[i]) <span class="keyword">return</span>(abc[i]);</div><div class="line">	&#125;</div><div class="line">&#125;<span class="comment">//密文还原操作；</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, keyy+<span class="number">1</span>, mi+<span class="number">1</span>);</div><div class="line">	<span class="comment">//直接将字符串输入到char数组中，从下标1开始存储；</span></div><div class="line">	len = <span class="built_in">strlen</span>(mi + <span class="number">1</span>); lenk = <span class="built_in">strlen</span>(keyy + <span class="number">1</span>);</div><div class="line">	<span class="comment">//strlen需使用头文件&lt;cstring&gt;；</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i ++) &#123;</div><div class="line">		key[i] = keyy[cnt];</div><div class="line">		<span class="keyword">if</span>(cnt == lenk) cnt = <span class="number">1</span>;</div><div class="line">		<span class="keyword">else</span> cnt ++;</div><div class="line">	&#125;<span class="comment">//将密钥循环存入数组，用于后来的还原明文操作；</span></div><div class="line">	</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) &#123;</div><div class="line">		abc[i] = <span class="string">'a'</span> + i - <span class="number">1</span>;	</div><div class="line">	&#125;<span class="comment">//将26位字母按字典序存入；</span></div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</div><div class="line">		<span class="keyword">if</span>(mi[i] &lt; <span class="number">97</span>) &#123;</div><div class="line">			flag[i] = <span class="number">1</span>;</div><div class="line">			mi[i] += <span class="number">32</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(key[i] &lt; <span class="number">97</span>) key[i] += <span class="number">32</span>;</div><div class="line">	&#125;<span class="comment">//大小写转换；</span></div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</div><div class="line">		light[i] = solve(mi[i], key[i]);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</div><div class="line">		<span class="keyword">if</span>(flag[i] == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%c"</span>, light[i] - <span class="number">32</span>);<span class="comment">//还原大写字母；</span></div><div class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%c"</span>, light[i]);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NOIP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「统计」离散化+Map]]></title>
      <url>/2017/10/25/%E3%80%8C%E7%BB%9F%E8%AE%A1%E3%80%8D%E7%A6%BB%E6%95%A3%E5%8C%96+Map/</url>
      <content type="html"><![CDATA[<p>  给定N个数，有M个询问。每次询问一段区间内有没有出现过Xi这个数。</p>
<a id="more"></a>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行一个整数N。<br>第二行N个正整数表示给定的N个数。<br>第三行一个整数M。<br>以下M行每行三个整数li，ri和Xi；表示询问区间是[li, ri]，询问数字是Xi。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每一次询问，输出一个字符。0表示没出现，1表示出现了。</p>
<h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">5</div><div class="line">1234567 666666 3141593 666666 4343434</div><div class="line">5</div><div class="line">1 5 3141593</div><div class="line">1 5 578202</div><div class="line">2 4 666666</div><div class="line">4 4 7135610</div><div class="line">1 1 1234567</div></pre></td></tr></table></figure>
<h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><pre><code>10101
</code></pre><h4 id="数据说明"><a href="#数据说明" class="headerlink" title="数据说明"></a>数据说明</h4><p>40%的数据满足：<code>N≤1000，M≤10001</code></p>
<p>100%的数据满足：<code>N≤10e9，M≤10e5，Xi≤10e9</code></p>
<hr>
<p>这道题有很多种解法，在这里介绍一个用map离散化的做法；其实数据够良心，直接for循环打暴力也可以得到40分的（亲测）；</p>
<p>用map（stl）储存数据，以数字为标志，再开一个vector数组存该数据出现过的位置，直接看位置数据内是否有存在所输入查询范围内的个体；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, m, l, r, x, y;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> res = <span class="number">0</span>; <span class="keyword">int</span> flag = <span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span>(ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) &#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>) flag = <span class="number">-1</span>; ch = getchar();&#125;</div><div class="line">	<span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;res = res * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = getchar();&#125;</div><div class="line">	<span class="keyword">return</span> (res * flag);</div><div class="line">&#125;</div><div class="line"><span class="comment">//高天宇快读；</span></div><div class="line"></div><div class="line"><span class="built_in">map</span> &lt; <span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; mapp;</div><div class="line"><span class="comment">//用int型映射一个int类型的vector；</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapp[x].size(); i++) &#123;</div><div class="line">		<span class="keyword">if</span>(mapp[x][i] &gt;= l &amp;&amp; mapp[x][i] &lt;= r) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	freopen(<span class="string">"statistic.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">	freopen(<span class="string">"statistic.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</div><div class="line">	n = read();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">		y = read();</div><div class="line">		mapp[y].push_back(i);</div><div class="line">	&#125;</div><div class="line">	m = read();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">		l = read(); r = read(); x = read();</div><div class="line">		<span class="keyword">if</span>(query(l, r, x)) <span class="built_in">printf</span>(<span class="string">"1"</span>);</div><div class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"0"</span>);</div><div class="line">	&#125;</div><div class="line">	fclose(<span class="built_in">stdin</span>);</div><div class="line">	fclose(<span class="built_in">stdout</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> STL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「codevs1073」并查集]]></title>
      <url>/2017/10/22/1073/</url>
      <content type="html"><![CDATA[<p><a href="http://codevs.cn/problem/1073/" target="_blank" rel="external">题目链接</a></p>
<p>若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。 规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。</p>
<a id="more"></a>
<h4 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h4><p>第一行：三个整数<strong>n,m,p，（n&lt;=5000,m&lt;=5000,p&lt;=5000）</strong>，分别表示有n个人，m个亲戚关系，询问p对亲戚关系。 以下m行：每行两个数Mi，Mj，<strong>1&lt;=Mi，Mj&lt;=N</strong>，表示Ai和Bi具有亲戚关系。 接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。</p>
<h4 id="输出描述-Output-Description"><a href="#输出描述-Output-Description" class="headerlink" title="输出描述 Output Description"></a>输出描述 Output Description</h4><p>P行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。</p>
<h4 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">6 5 3</div><div class="line"></div><div class="line">1 2</div><div class="line"></div><div class="line">1 5</div><div class="line"></div><div class="line">3 4</div><div class="line"></div><div class="line">5 2</div><div class="line"></div><div class="line">1 3</div><div class="line"></div><div class="line">1 4</div><div class="line"></div><div class="line">2 3</div><div class="line"></div><div class="line">5 6</div></pre></td></tr></table></figure>
<h4 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Yes</div><div class="line"></div><div class="line">Yes</div><div class="line"></div><div class="line">No</div></pre></td></tr></table></figure>
<p>并查集裸题，就当给dalao递板子了，虽然我比较弱，还是说一下自己的理解；其实并查集呢，我们就把它想象成一棵树，存在只有自己一个节点的树，也存在拥有多个节点的树，只要是连通，我们就说他们位于同一个树中，合并并查集呢，就是将两棵树的树根连接在一起咯；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> res = <span class="number">0</span>; <span class="keyword">int</span> flag = <span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span>(ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>) &#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>) flag = <span class="number">-1</span>; ch = getchar();&#125;</div><div class="line">	<span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;res = res * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = getchar();&#125;</div><div class="line">	<span class="keyword">return</span> (res * flag);</div><div class="line">&#125;</div><div class="line"><span class="comment">//高天宇的快读，大家可以拿去用；</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> n, m, p;</div><div class="line"><span class="keyword">int</span> father[<span class="number">5000</span> + <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> father[x] == x ? x : father[x] = find(father[x]);</div><div class="line">&#125;</div><div class="line"><span class="comment">//寻找父亲（根节点）的操作；</span></div><div class="line"><span class="comment">//路径压缩，回溯的时候就顺带把父亲们直接连接在根节点上，那么节点们寻找根节点的路径</span></div><div class="line"><span class="comment">//就变短了，所以称为路径压缩；</span></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> r1 = find(x); <span class="keyword">int</span> r2 = find(y);</div><div class="line">	<span class="keyword">if</span>(r1 == r2) <span class="keyword">return</span>;</div><div class="line">	<span class="keyword">else</span> father[r1] = r2;</div><div class="line">&#125;</div><div class="line"><span class="comment">//合并操作；如果不是同一个父亲（根节点），则把两棵子树通过各自的根节点连在一起；</span></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> find(x) == find(y) ? <span class="literal">true</span> : <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//判断是不是同一个父亲；</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	n = read(); m = read(); p = read();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) father[i] = i;</div><div class="line">    <span class="comment">//千万别忘了初始化！！！</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</div><div class="line">		<span class="keyword">int</span> x = read(); <span class="keyword">int</span> y = read();</div><div class="line">		merge(x, y);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; ++ i) &#123;</div><div class="line">		<span class="keyword">int</span> x1 = read(); <span class="keyword">int</span> x2 = read();</div><div class="line">		<span class="keyword">if</span>(judge(x1, x2)) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</div><div class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「codevs2370」LCA-倍增]]></title>
      <url>/2017/10/22/2370/</url>
      <content type="html"><![CDATA[<p><a href="http://codevs.cn/problem/2370/" target="_blank" rel="external">题目链接</a></p>
<p>  小机房有棵焕狗种的树，树上有N个节点，节点标号为<strong>0到N-1</strong>，有两只虫子名叫飘狗和大吉狗，分居在两个不同的节点上。有一天，他们想爬到一个节点上去搞基，但是作为两只虫子，他们不想花费太多精力。已知从某个节点爬到其父亲节点要花费<strong> c</strong> 的能量（从父亲节点爬到此节点也相同），他们想找出一条花费精力最短的路，以使得搞基的时候精力旺盛，他们找到你要你设计一个程序来找到这条路，要求你告诉他们最少需要花费多少精力</p>
<a id="more"></a>
<h4 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h4><p>第一行一个n，接下来n-1行每一行有三个整数u，v, c 。表示节点 u 爬到节点 v 需要花费 c 的精力。<br>第n+1行有一个整数m表示有m次询问。接下来m行每一行有两个整数 u ，v 表示两只虫子所在的节点<br>输出描述 Output Description<br>一共有m行，每一行一个整数，表示对于该次询问所得出的最短距离。</p>
<h4 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">3</div><div class="line"></div><div class="line">1 0 1</div><div class="line"></div><div class="line">2 0 1</div><div class="line"></div><div class="line">3</div><div class="line"></div><div class="line">1 0</div><div class="line"></div><div class="line">2 0</div><div class="line"></div><div class="line">1 2</div></pre></td></tr></table></figure>
<h4 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line"></div><div class="line">1</div><div class="line"></div><div class="line">2</div></pre></td></tr></table></figure>
<h4 id="数据范围及提示-Data-Size-amp-Hint"><a href="#数据范围及提示-Data-Size-amp-Hint" class="headerlink" title="数据范围及提示 Data Size &amp; Hint"></a>数据范围及提示 Data Size &amp; Hint</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">1&lt;=n&lt;=50000， 1&lt;=m&lt;=75000， 0&lt;=c&lt;=1000</div></pre></td></tr></table></figure>
<p>这是一道lca（最近公共祖先）的裸题， 我们只需要求出两点到根节点的距离和， 再用 距离和 减去 两次 lca到根节点的距离，即为两点间的最短路径长度；</p>
<p>那么lca要怎么求呢？ 我们一起来看一看！ 首先我们需要定义一个数组depth[i]记录i点的深度（通过函数dfs求出）；一个二维数组father[x][i]记录点x向上2的i次方的祖先（通过函数pow_init求出）；已知x，y求lca的方法：看x,y两点是否为同一深度，我们移动较深的点直至两点位于同一深度，然后从2的i次方开始跳（i为 上跳2的i次方 最大不超过根节点 时i的值），i递减，如果跳到同一点，则不跳（防止跳过lca到了别的点），最后我们肯定会走到离lca深度为1的点，再跳一个深度即可！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> max(x, y) ((x) &gt; (y) ? (x) : (y))</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50000</span> + <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></div><div class="line">	<span class="keyword">int</span> to, w, next;</div><div class="line">&#125; edge[MAXN * <span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, m, num, logn, deep;</div><div class="line"><span class="keyword">int</span> head[MAXN], depth[MAXN], dis[MAXN];</div><div class="line"><span class="keyword">int</span> father[MAXN][<span class="number">20</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</div><div class="line">	edge[++num].to = to;</div><div class="line">	edge[num].w = w;</div><div class="line">	edge[num].next = head[from];</div><div class="line">	head[from] = num;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> cur)</span> </span>&#123; <span class="comment">// x是点， cur是点的深度；</span></div><div class="line">	depth[x] = cur;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = edge[i].next) &#123; <span class="comment">// 遍历；</span></div><div class="line">		<span class="keyword">if</span>(depth[edge[i].to]) <span class="keyword">continue</span>; <span class="comment">// 如果这个点是父亲；</span></div><div class="line">		father[edge[i].to][<span class="number">0</span>] = x;</div><div class="line">		dis[edge[i].to] = edge[i].w + dis[x];<span class="comment">//预处理树的前缀和；</span></div><div class="line">		deep = max(deep, depth[x]); <span class="comment">// 求树的深度；</span></div><div class="line">		dfs(edge[i].to, depth[x] + <span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pow_init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;(<span class="number">1</span> &lt;&lt; j) &lt;= deep;j ++) &#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123;</div><div class="line">			father[i][j] = father[father[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</div><div class="line">            <span class="comment">//倍增的运用，dalao自行脑补或者画张图，一张图很明了的， 倍增：这样可以借助之前的点做跳板，如果想暴力一个一个地枚举也可以，但是就比较慢了；</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//遍历出父亲；</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(depth[x] &lt; depth[y]) <span class="built_in">std</span>::swap(x, y);</div><div class="line">	<span class="keyword">if</span>(depth[x] != depth[y]) &#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = logn; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">			<span class="keyword">if</span>(depth[x] - (<span class="number">1</span> &lt;&lt; i) &gt;= depth[y]) &#123;</div><div class="line">            <span class="comment">//如果没有跳多； 就跳！；</span></div><div class="line">				x = father[x][i];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</div><div class="line">   <span class="comment">//如果跳到同一深度就是同一个点，说明两点在同一路径上面，找到了！；</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = logn; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">		<span class="keyword">if</span>(father[x][i] == father[y][i]) <span class="keyword">continue</span>;</div><div class="line">		x = father[x][i]; y = father[y][i];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> father[x][<span class="number">0</span>];<span class="comment">//再向上一部</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</div><div class="line">		<span class="keyword">int</span> u, v, c;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;c);</div><div class="line">		add_edge(u, v, c);</div><div class="line">		add_edge(v, u, c);</div><div class="line">	&#125;</div><div class="line">	dfs(<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">	pow_init(n);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= deep; i++) logn = i;logn++;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">		<span class="keyword">int</span> x, y;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</div><div class="line">		<span class="keyword">int</span> r = LCA(x, y);</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dis[x] + dis[y] - dis[r] * <span class="number">2</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[字符串STL]]></title>
      <url>/2017/10/22/%E5%AD%97%E7%AC%A6%E4%B8%B2STL/</url>
      <content type="html"><![CDATA[<p>参考 （侵权必删）： <a href="http://www.360doc.com/content/10/1006/18/1704901_58868298.shtml" target="_blank" rel="external">http://www.360doc.com/content/10/1006/18/1704901_58868298.shtml</a></p>
<p><a href="http://blog.csdn.net/f_c_g_/article/details/51228909" target="_blank" rel="external">http://blog.csdn.net/f_c_g_/article/details/51228909</a></p>
<p>dalao们总结的够好了， 我就做一个传播者咯(ง •_•)ง<br><a id="more"></a>          </p>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> STL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vector-不定长数组]]></title>
      <url>/2017/10/20/Vector-%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<p>不定长数组<strong>vector</strong>是一个<strong>stl</strong>库中的容器；类似于数组，因其有不定长的特性，故在<strong>一些情况下</strong>可以<strong>节省空间</strong>；</p>
<p>调用vector需要挂头文件<code>&lt;vector&gt;</code>;<br>还需要注明<code>std</code>；</p>
<a id="more"></a>
<h4 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h4><p>·我们先来定义一个int型的vector数组： <code>vector &lt;int&gt; vec</code></p>
<p>·新增元素i至数组尾部：<code>vec.push_back(i)</code></p>
<p>·删除数组尾部的元素：<code>vec.pop_back()</code></p>
<p>·回传vector第一个元素的值：<code>vec.front()</code></p>
<p>·回传vector数组最尾部元素的值：<code>vec.back()</code></p>
<p>·存取索引值为i的元素值：<code>vec[i] 或者 vec.(i)</code>//前提是位置已开出</p>
<p>·清空vector数组内的元素：<code>vec.clear()</code></p>
<p>·判断数组是否为空(如果为空，返回true)：<code>vec.empty()</code> </p>
<p>·获取vector数组目前拥有的元素个数：<code>vec.size()</code></p>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> STL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「codevs1047」DP + 搜索]]></title>
      <url>/2017/10/19/1047/</url>
      <content type="html"><![CDATA[<p><a href="http://codevs.cn/problem/1047/" target="_blank" rel="external">题目链接</a></p>
<p>  给定一个信封，最多只允许粘贴N张邮票，计算在给定K（N+K≤40）种邮票的情况下（假定所有的邮票数量都足够），如何设计邮票的面值，能得到最大值MAX，使在1～MAX之间的每一个邮资值都能得到。</p>
<p>例如，N=3，K=2，如果面值分别为1分、4分，则在1分～6分之间的每一个邮资值都能得到（当然还有8分、9分和12分）；如果面值分别为1分、3分，则在1分～7分之间的每一个邮资值都能得到。可以验证当N=3，K=2时，7分就是可以得到的连续的邮资最大值，所以MAX=7，面值分别为1分、3分。</p>
<a id="more"></a>
<h4 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h4><pre><code>N和K
</code></pre><h4 id="输出描述-Output-Description"><a href="#输出描述-Output-Description" class="headerlink" title="输出描述 Output Description"></a>输出描述 Output Description</h4><p>每种邮票的面值，连续最大能到的面值数。数据保证答案唯一。</p>
<h4 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h4><pre><code>3 2
</code></pre><h4 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h4><pre><code>1 3
MAX=7
</code></pre><p>看过题面， 我们发现这好像可以通过搜索来AC， 但又要用到一定的动归思想，Go for it!</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> max(x, y) ((x) &gt; (y) ? (x) : (y))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> min(x, y) ((x) &lt; (y) ? (x) : (y))</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e8</span>;</div><div class="line"><span class="keyword">int</span> n, k, ans, sum; </div><div class="line"><span class="keyword">int</span> a[<span class="number">1000</span> + <span class="number">5</span>], dp[<span class="number">1000</span> + <span class="number">5</span>]， b[<span class="number">1000</span> + <span class="number">5</span>];</div><div class="line"><span class="comment">//b数组用来储存结果， 因为a数组经过了多次变动；</span></div><div class="line"><span class="comment">//a数组用来储存起始数据；</span></div><div class="line"><span class="comment">//dp[i]达到i值最少需要多少张牌</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) &#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>) flag = <span class="number">-1</span>; ch = getchar();&#125;</div><div class="line">	<span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;res = res * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = getchar();&#125;</div><div class="line">	<span class="keyword">return</span> (res * flag);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">()</span> </span>&#123;</div><div class="line">	dp[<span class="number">1</span>] = <span class="number">1</span>; <span class="keyword">int</span> i; <span class="comment">//赋初值</span></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">2</span>; ; i++) &#123;</div><div class="line">		dp[i] = INF;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k &amp;&amp; i - a[j] &gt;= <span class="number">0</span>; j++) &#123;</div><div class="line">			dp[i] = min(dp[i], dp[i - a[j]] + <span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">        <span class="comment">//j &lt;= k (j 是种类， 所以一定是&lt;=K)</span></div><div class="line">        <span class="comment">//i - a[j] &gt;= 0; 我们可以不选（dp[0] = 0）,但所选择的数值肯定是不能大于i的；</span></div><div class="line">		<span class="keyword">if</span> (dp[i] &gt; n) <span class="keyword">break</span>;</div><div class="line">        <span class="comment">//用的数量已经大于最大可选数量；</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (i - <span class="number">1</span> &gt; ans) &#123;<span class="comment">//因为i++，所以其实大1，故要减一，让新结果与旧的结果相比较；</span></div><div class="line">		ans = i - <span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</div><div class="line">		    b[i] = a[i];   </div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 以第几种面值为参数</span></div><div class="line">	<span class="keyword">if</span>(x == k + <span class="number">1</span>) &#123;</div><div class="line">		DP(); <span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = a[x - <span class="number">1</span>] + <span class="number">1</span>; i &lt;= a[x - <span class="number">1</span>] * n + <span class="number">1</span>; i++) &#123;</div><div class="line">		a[x] = i;</div><div class="line">		dfs(x + <span class="number">1</span>); <span class="comment">//一颗树形结构，不断向下分支，再return上去；</span></div><div class="line">	&#125;</div><div class="line">    <span class="comment">//a[x - 1] + 1 加上新数值最起码大1；</span></div><div class="line">    <span class="comment">//a[x - 1] * n + 1 加1保证其连续性， 加2的话就不再连续了；</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	n = read(); k = read();</div><div class="line">	a[<span class="number">1</span>] = <span class="number">1</span>; ans = k;</div><div class="line">	dfs(<span class="number">2</span>);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) <span class="built_in">cout</span> &lt;&lt; b[i] &lt;&lt; <span class="string">" "</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"MAX="</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP - 搜索 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「codevs3027」序列DP]]></title>
      <url>/2017/10/18/3027/</url>
      <content type="html"><![CDATA[<p><a href="http://codevs.cn/problem/3027/" target="_blank" rel="external">题目链接</a></p>
<p>  数轴上有n条线段，线段的两端都是整数坐标，坐标范围在0~1000000，每条线段有一个价值，请从n条线段中挑出若干条线段，使得这些线段两两不覆盖（端点可以重合）且线段价值之和最大。</p>
<pre><code>n&lt;=1000
</code></pre><a id="more"></a>
<h4 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h4><p>第一行一个整数n，表示有多少条线段。</p>
<p>接下来n行每行三个整数, ai bi ci，分别代表第i条线段的左端点ai，右端点bi（保证左端点&lt;右端点）和价值ci。</p>
<p>输出描述 Output Description<br>输出能够获得的最大价值</p>
<h4 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3</div><div class="line"></div><div class="line">1 2 1</div><div class="line"></div><div class="line">2 3 2</div><div class="line"></div><div class="line">1 3 4</div></pre></td></tr></table></figure>
<h4 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h4><pre><code>4
</code></pre><h4 id="数据范围及提示-Data-Size-amp-Hint"><a href="#数据范围及提示-Data-Size-amp-Hint" class="headerlink" title="数据范围及提示 Data Size &amp; Hint"></a>数据范围及提示 Data Size &amp; Hint</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">对于40%的数据，n≤10；</div><div class="line"></div><div class="line">对于100%的数据，n≤1000；</div><div class="line"></div><div class="line">0&lt;=ai,bi&lt;=1000000</div><div class="line"></div><div class="line">0&lt;=ci&lt;=1000000</div></pre></td></tr></table></figure>
<p>首先对这道题展开分析，可以看出这是一道DP题，但是我们怎么做呢？我们首先建立一个结构体将每条线段的左端点和右端点及价值储存，按照<strong>右端点</strong>进行sort操作（<strong>用来保证左边尽可能持有更多的边</strong>）； 建立一个数组f[i],用来储存到<br>编号为i的这条边我们所拥有的最大价值；遍历求出发f[i]，然后max函数找到最大值；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> max(x, y) ((x) &gt; (y) ? (x) : (y))</span></div><div class="line"><span class="comment">//这里将x，y单独加括号的原因是防止三目运算时参数x或y传的是一个式子；</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, sum, f[<span class="number">1000</span> + <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) &#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>) flag = <span class="number">-1</span>; ch = getchar();&#125;</div><div class="line">	<span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;res = res * <span class="number">10</span> + ch - <span class="string">'0'</span>; ch = getchar();&#125;</div><div class="line">	<span class="keyword">return</span> (res * flag);</div><div class="line">&#125;<span class="comment">//快读（高天宇） 只能读数，不可读字符</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></div><div class="line">	<span class="keyword">int</span> l, r, c;</div><div class="line">	Line(<span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>) : l(l), r(r), c(c) &#123;&#125;</div><div class="line">&#125;line[<span class="number">1000</span> + <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Line a, Line b)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> a.r &lt; b.r;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	n = read();</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">		line[i].l = read();</div><div class="line">		line[i].r = read();</div><div class="line">		line[i].c = read();</div><div class="line">	&#125;</div><div class="line">	sort(line + <span class="number">1</span>, line + n + <span class="number">1</span>, cmp);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;  i &lt;= n; i++) f[i] = line[i].c;</div><div class="line">    <span class="comment">//赋值操作一定要加在sort之后； 因为sort会改变line[i].c的位置；</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++) &#123;</div><div class="line">			<span class="keyword">if</span>(line[j].r &lt;= line[i].l) &#123;</div><div class="line">				f[i] = max(f[i], f[j] + line[i].c);<span class="comment">//转移方程</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">		sum = max(sum, f[i]);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, sum);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「codevs1078」Kruskal]]></title>
      <url>/2017/10/17/1078/</url>
      <content type="html"><![CDATA[<p><a href="http://codevs.cn/problem/1078/" target="_blank" rel="external">题目链接</a></p>
<p>  农民约翰被选为他们镇的镇长！他其中一个竞选承诺就是在镇上建立起互联网，并连接到所有的农场。当然，他需要你的帮助。 约翰已经给他的农场安排了一条高速的网络线路，他想把这条线路共享给其他农场。为了使花费最少，他想铺设最短的光纤去连接所有的农场。 你将得到一份各农场之间连接费用的列表，你必须找出能连接所有农场并所用光纤最短的方案。 每两个农场间的距离不会超过100000</p>
<a id="more"></a>
<h4 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h4><p>第一行： 农场的个数，<strong>N（3&lt;=N&lt;=100）</strong>。</p>
<p>第二行..结尾: 接下来的行包含了一个N*N的矩阵,表示每个农场之间的距离。理论上，他们是N行，每行由N个用空格分隔的数组成，实际上，他们每行限制在80个字符以内，因此，某些行会紧接着另一些行。当然，对角线将会是0，因为线路从第i个农场到它本身的距离在本题中没有意义。</p>
<h4 id="输出描述-Output-Description"><a href="#输出描述-Output-Description" class="headerlink" title="输出描述 Output Description"></a>输出描述 Output Description</h4><p>只有一个输出，是连接到每个农场的光纤的最小长度和。</p>
<h4 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">4</div><div class="line"></div><div class="line">0  4  9 21</div><div class="line"></div><div class="line">4  0  8 17</div><div class="line"></div><div class="line">9  8  0 16</div><div class="line"></div><div class="line">21 17 16  0</div></pre></td></tr></table></figure>
<h4 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h4><pre><code>28
</code></pre><p>这是一道最小生成树模板题，最小生成树算法的巧妙之处在于它使用了<strong>并查集</strong>和<strong>贪心</strong>的相关知识；首先我们将边读入，然后呢，将编权从小到大排序；按照边权从小到大的顺序依次加边，每加入一条边，将其两端点加入并查集内，直到所有的边都加入并查集内时，最小生成树便生成了！<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">"="</span> &lt;&lt; x &lt;&lt; std::endl</span></div><div class="line"><span class="comment">//用于debug的一个操作，可忽略；</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, m;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></div><div class="line">	<span class="keyword">int</span> s, t, w;</div><div class="line">&#125; edge[MAXN * MAXN];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> a.w &lt; b.w;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> father[MAXN];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> x == father[x] ? x : father[x] = find(father[x]);</div><div class="line">&#125;</div><div class="line"><span class="comment">//并查集find操作；</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">    <span class="comment">//res用于存最小总权值；</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) father[i] = i;</div><div class="line">    <span class="comment">//并查集初始化；</span></div><div class="line">	<span class="built_in">std</span>::sort(edge + <span class="number">1</span>, edge + m + <span class="number">1</span>, cmp);</div><div class="line">    <span class="comment">//将边权排序；</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">		<span class="keyword">int</span> fx = find(edge[i].s), fy = find(edge[i].t);</div><div class="line">		<span class="keyword">if</span> (fx != fy) &#123;</div><div class="line">			father[fx] = fy;</div><div class="line">			res += edge[i].w;</div><div class="line">		&#125;</div><div class="line">        <span class="comment">//将边加入；</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</div><div class="line">			edge[++m].s = i, edge[m].t = j;</div><div class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;edge[m].w);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, kruskal());</div><div class="line">			</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「codevs1557」Dijkstra]]></title>
      <url>/2017/10/15/1557/</url>
      <content type="html"><![CDATA[<p><a href="http://codevs.cn/problem/1557/" target="_blank" rel="external">题目链接</a></p>
<p>   德克萨斯纯朴的民眾们这个夏天正在遭受巨大的热浪！！！他们的德克萨斯长角牛吃起来不错，可是他们并不是很擅长生產富含奶油的乳製品。Farmer John此时以先天下之忧而忧，后天下之乐而乐的精神，身先士卒地承担起向德克萨斯运送大量的营养冰凉的牛奶的重任，以减轻德克萨斯人忍受酷暑的痛苦。</p>
<p>FJ已经研究过可以把牛奶从威斯康星运送到德克萨斯州的路线。这些路线包括起始点和终点先一共经过T <strong>(1 &lt;= T &lt;= 2,500)</strong>个城镇，方便地标号為1到<strong>T</strong>。除了起点和终点外地每个城镇由两条双向道路连向至少两个其它地城镇。每条道路有一个通过费用（包括油费，过路费等等）。</p>
<p>给定一个地图，包含C<strong> (1 &lt;= C &lt;= 6,200)</strong>条直接连接2个城镇的道路。每条道路由道路的起点Rs，终点Re <strong>(1 &lt;= Rs &lt;= T; 1 &lt;= Re &lt;= T)</strong>，和花费<strong>(1 &lt;= Ci &lt;= 1,000)</strong>组成。求从起始的城镇Ts <strong>(1 &lt;= Ts &lt;= T)</strong>到终点的城镇Te<strong>(1 &lt;= Te &lt;= T)</strong>最小的总费用。</p>
<a id="more"></a>
<h4 id="输入描述-Input-Description"><a href="#输入描述-Input-Description" class="headerlink" title="输入描述 Input Description"></a>输入描述 Input Description</h4><p>第一行: 4个由空格隔开的整数:<code>T, C, Ts, Te</code></p>
<p>第2到第<code>C+1</code>行: 第<code>i+1</code>行描述第i条道路。有3个由空格隔开的整数:<code>Rs, Re和Ci</code></p>
<h4 id="输出描述-Output-Description"><a href="#输出描述-Output-Description" class="headerlink" title="输出描述 Output Description"></a>输出描述 Output Description</h4><p>一个单独的整数表示从Ts到Te的最小总费用。数据保证至少存在一条道路。</p>
<h4 id="样例输入-Sample-Input"><a href="#样例输入-Sample-Input" class="headerlink" title="样例输入 Sample Input"></a>样例输入 Sample Input</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">7 11 5 4</div><div class="line"></div><div class="line">2 4 2</div><div class="line"></div><div class="line">1 4 3</div><div class="line"></div><div class="line">7 2 2</div><div class="line"></div><div class="line">3 4 3</div><div class="line"></div><div class="line">5 7 5</div><div class="line"></div><div class="line">7 3 3</div><div class="line"></div><div class="line">6 1 1</div><div class="line"></div><div class="line">6 3 4</div><div class="line"></div><div class="line">2 4 3</div><div class="line"></div><div class="line">5 6 3</div><div class="line"></div><div class="line">7 2 1</div></pre></td></tr></table></figure>
<h4 id="样例输出-Sample-Output"><a href="#样例输出-Sample-Output" class="headerlink" title="样例输出 Sample Output"></a>样例输出 Sample Output</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">7</div></pre></td></tr></table></figure>
<h4 id="数据范围及提示-Data-Size-amp"><a href="#数据范围及提示-Data-Size-amp" class="headerlink" title="数据范围及提示 Data Size &amp;"></a>数据范围及提示 Data Size &amp;</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hint</div><div class="line">5-&gt;6-&gt;1-&gt;4 (3 + 1 + 3)</div></pre></td></tr></table></figure>
<p>本题是一道单源最短路<strong>Dijkstra</strong>算法的模板题，让我们一起探讨吧！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2500</span> + <span class="number">5</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">12400</span> + <span class="number">5</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3</span>;</div><div class="line"><span class="keyword">int</span> head[MAXN], dist[MAXN],  n, m, num, start, end;</div><div class="line"><span class="comment">//head数组记录存的是在这条边被加入之前的最后一条边（边表的一端）；</span></div><div class="line"><span class="comment">//dist数组储存起点到这个点的距离</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></div><div class="line">	<span class="keyword">int</span> from, to, next, w;</div><div class="line">&#125;edge[MAXM];</div><div class="line"><span class="comment">//用于建图</span></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</div><div class="line">	edge[++num].from = from;</div><div class="line">	edge[num].to = to;</div><div class="line">	edge[num].w = w;</div><div class="line">	edge[num].next = head[from];</div><div class="line">    <span class="comment">//next存上一条边（整条边）</span></div><div class="line">	head[from] = num;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dist</span> &#123;</span></div><div class="line">	<span class="keyword">int</span> x, dist;</div><div class="line">	Dist(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> dist = inf) : x(x), dist(dist) &#123;&#125;</div><div class="line">    <span class="comment">//结构体初始化</span></div><div class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(Dist l, Dist r)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> l.dist &gt; r.dist;</div><div class="line">	&#125;</div><div class="line">    <span class="comment">//重载运算符：按从小到大排序；</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">priority_queue &lt;Dist, <span class="built_in">vector</span>&lt;Dist&gt;, Dist&gt; que;</div><div class="line"><span class="comment">//建立一个以Dist为元素的不定长数组；</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = inf;</div><div class="line">	dist[start] = <span class="number">0</span>;</div><div class="line">	que.push(Dist(start, <span class="number">0</span>));</div><div class="line">    <span class="comment">//初始化操作；</span></div><div class="line">	<span class="keyword">while</span>(!que.empty()) &#123;</div><div class="line">    <span class="comment">//while(!que.empty())  如果队列为空返回一  取非之后返回零；也就是说当队列不为空时；</span></div><div class="line">		Dist tmp = que.top();</div><div class="line">		que.pop();</div><div class="line">		<span class="keyword">if</span>(tmp.dist != dist[tmp.x]) <span class="keyword">continue</span>;</div><div class="line">       <span class="comment">//因为队列里面的数是不断更新的，如果不等于，说明这个点比较旧了，然而我们需要的其实是最新的点，所以就把它continue掉；</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = head[tmp.x]; j; j = edge[j].next) &#123;</div><div class="line">			<span class="keyword">if</span>(dist[edge[j].to] &gt; dist[tmp.x] + edge[j].w) &#123;</div><div class="line">				dist[edge[j].to] = dist[tmp.x] + edge[j].w;</div><div class="line">				que.push(Dist(edge[j].to, dist[edge[j].to]));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">        <span class="comment">//遍历求距；</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> dist[end];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;start, &amp;end);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</div><div class="line">		<span class="keyword">int</span> x, y, z;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</div><div class="line">		add_edge(x, y, z);</div><div class="line">		add_edge(y, x, z);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, dijkstra());</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
